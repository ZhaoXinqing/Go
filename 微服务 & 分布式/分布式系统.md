## 分布式系统是什么? ##
**集中式系统：** 整个应用也就是整个项目，所有的东西都在一个应用里面。**优点** 就是开发测试运维会比较方便，不用为考虑复杂的分布式环境。 **弊端** 就是不易扩展，每次更新都必须更新所有的应用。而且，一个有问题意味着所有的应用都有问题。当系统越来越大，集中式将是系统最大的瓶颈。

**分布式系统：** 分布式系统背后是由一系列的计算机组成的，但用户感知不到背后的逻辑，就像访问单个计算机一样。




## 分布式系统解决了什么问题，它又引入了新的什么问题？ ##
在分布式系统中：（分布式系统特点）
1. 应用可以按业务类型拆分成多个；
1. 数据库可以按业务类型拆分成多个实例，可以对单表进行分库分表；
1. 增加分布式缓存、搜索、文件、消息队列、非关系型数据库等中间件；

**优点：**，解决集中式不便扩展的弊端，可以在任何一个环节扩展应用，就算一个应用出现问题也不会影响到别的应用。
**缺点**，**增加了系统的复杂性**，如分布式事务、分布式锁、分布式session、数据一致性等。**增加了开发测试运维成本**，工作量增加，分布式系统管理不好反而会变成一种负担。

## Etcd、分布式锁? ##
是一个**键值存储仓库**，用于配置共享和服务发现。

**Etcd如何实现分布式锁?**
因为 Etcd 使用 Raft 算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。
（1）保持独占：保持独占即所有获取锁的用户最终只有一个可以得到。etcd 为此提供了一套实现分布式锁原子操作 CAS（CompareAndSwap）的 API。通过设置prevExist值，可以保证在多个节点同时去创建某个目录时，只有一个成功。而创建成功的用户就可以认为是获得了锁。

（2）控制时序：即所有想要获得锁的用户都会被安排执行，但是获得锁的顺序也是全局唯一的，同时决定了执行顺序。etcd 为此也提供了一套 API（自动创建有序键），对一个目录建值时指定为POST动作，这样 etcd 会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。同时还可以使用 API 按顺序列出所有当前目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。

**基本实现原理为：**
1. 在ectd系统里创建一个key
1. 如果创建失败，key存在，则监听该key的变化事件，直到该key被删除，回到1
1. 如果创建成功，则认为我获得了锁

## 分布式锁的实现 ##
分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。

由于网络硬件肯定会出现延迟丢包等问题，所以分区容错性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。

通常分布式锁以单独的服务方式实现，目前比较常用的分布式锁实现有三种：

### （1）基于数据库的实现方式 ###
在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。

实现方式很简单，但是对于分布式锁应该具备的条件来说，它有一些问题需要解决及优化：

1. 因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要**双机部署、数据同步、主备切换**；
1. 不具备可重入的特性，需要在表中**新增一列，用于记录当前获取到锁的机器和线程信息**，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁；
1. 没有锁失效机制，需要在表中**新增一列，用于记录失效时间**，并且需要有定时任务清除这些失效的数据；
1. 不具备阻塞锁特性，获取不到锁直接返回失败，所以**需要优化获取逻辑，循环多次去获取**。
1. 依赖数据库需要一定的**资源开销，性能问题需要考虑**。

### （2）基于Redis的实现方式 ###
选用Redis实现分布式锁原因：

1. Redis有很高的性能；
1. Redis命令对此支持较好，实现起来比较方便

主要实现方式:

1. SET lock currentTime+expireTime EX 600 NX，使用set设置lock值，并设置过期时间为600秒，如果成功，则获取锁；
1. 获取锁后，如果该节点掉线，则到过期时间lock值自动失效；
1. 释放锁时，使用del删除lock键值；

使用redis单机来做分布式锁服务，可能会出现单点问题，导致服务可用性差，因此在服务稳定性要求高的场合，官方建议使用redis集群（例如5台，成功请求锁超过3台就认为获取锁），来实现redis分布式锁。详见RedLock。

- 优点：性能高，redis可持久化，也能保证数据不易丢失,redis集群方式提高稳定性。
- 缺点：使用redis主从切换时可能丢失部分数据。

### （3）基于ZooKeeper的实现方式 ###
ZooKeeper是一个 为 **分布式应用** 提供 **一致性服务** 的开源组件，它**内部是一个 分层的 文件系统 目录树结构**，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：

1. 创建一个目录mylock；
1. 线程A想获取锁就在mylock目录下创建临时顺序节点；
1. 获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
1. 线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
1. 线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。

这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。

- 优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。
- 缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。

上面的三种实现方式，没有在所有场合都是完美的，所以，应根据不同的应用场景选择最适合的实现方式。
在分布式环境中，对资源进行上锁有时候是很重要的，比如抢购某一资源，这时候使用分布式锁就可以很好地控制资源。

## 你对分布式事务的理解？ ##
分布式事务是 单个事件 导致两个或多个 不能以原子方式 提交的 单独数据源 的突变的情况。**在微服务的世界中，它变得更加复杂，因为每个服务都是一个工作单元，并且在大多数情况下，多个服务必须协同工作才能使业务成功。**