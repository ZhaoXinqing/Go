
分布式系统：
    - 是一种系统部署方式，是将一个系统拆分成多个子系统并分布到多个服务器上，但用户感知不到背后的逻辑，就像访问单个计算机一样。简单的说，是指将用户界面、控制台服务、数据库管理三个层次部署在不同的位置上。其中用户界面是客户端实现的功能，控制台服务是一个专门的服务器，数据管理是在一个专门的数据库服务器上实现的。
    - 优点：
        - 解决集中式不便扩展的弊端，既可以针对应用进行硬扩展（性能水平扩展），也可以对应用进行软扩展（增加分布式缓存、消息队列、非关系型数据库等中间件），还一定程度上提供了业务隔离，就算一个应用出现问题也不会影响到别的应用。
    - 缺点：
        - 增加了开发系统的复杂性：如分布式事务、分布式锁、分布式session、数据一致性等。
        - 增加了开发测试运维成本：工作量增加，分布式系统管理不好反而会变成一种负担。

分布式锁：
    - 锁服务可以分为两类，一个是保持独占，另一个是控制时序，分布式锁其实可以理解为：控制分布式系统有序的去对共享资源进行操作，通过互斥来保持一致性
    - 三种实现方案：	
        1、数据库实现（乐观锁）
            - 乐观锁实现
                - 一般是通过为数据库表添加一个 “version”字段来实现读取出数据时，将此版本号一同读出，之后更新时，对此版本号加1，在更新过程中，会对版本号进行比较，如果是一致的，没有发生改变，则会成功执行本次操作；如果版本号不一致，则会更新失败，实际就是个diff过程;
                - 缺点：
                    - 本一次的update操作，必须变为2次操作: select版本号一次；update一次，增加了数据库操作的次数
                    - 用基于数据库资源表的乐观锁，为保证数据一致性，一次业务流程中的多个资源都有一张资源表，在高并发的要求下，对数据库连接的开销一定是无法忍受；
                    - 乐观锁机制往往基于系统中的数据存储逻辑，因此可能会造成脏数据被更新到数据库中可能产生脏数据
        2、基于Redis的实现（推荐）；
            - 加锁：使用redis命令 set key value NX EX max-lock-time 实现加锁
                - jedis.set(key,value,"NX","EX",timeOut)【保证加锁的原子操作】
                - key就是redis的key值作为锁的标识，value在这里作为客户端的标识，只有key-value都比配才有删除锁的权利【保证安全性】
                - 通过timeOut设置过期时间保证不会出现死锁【避免死锁】
                - NX：只有这个key不存才的时候才会进行操作，if not exists；
                - EX：设置key的过期时间为秒，具体时间由第5个参数决定
            - 解锁：使用redis命令 EVAL 实现解锁
                - luaScript 这个字符串是个lua脚本，代表的意思是如果根据key拿到的value跟传入的value相同就执行del，否则就返回0【保证安全性】
                - jedis.eval(String,list,list);这个命令就是去执行lua脚本，KEYS的集合就是第二个参数，ARGV的集合就是第三参数【保证解锁的原子操作】
        3、基于zookeeper的实现：
            - ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。
            - 使用zookeeper创建临时序列节点来实现分布式锁，适用于顺序执行的程序，大体思路就是创建临时序列节点，找出最小的序列节点，获取分布式锁，程序执行完成之后此序列节点消失，通过watch来监控节点的变化，从剩下的节点的找到最小的序列节点，获取分布式锁，执行相应处理，依次类推……
            
分布式事务：
    - 解决分布式事务的两个理论：
        - CAP理论:
            - 分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。
            - 由于网络硬件肯定会出现延迟丢包等问题，所以分区容错性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。
        - BASE理论:
            - 是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写。
            - 是对CAP中一致性和可用性权衡的结果，它减少的对数据一致性支持，从而获得了基本一致性和柔和可靠性，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。       
    - 如何确保分布式事务？
        - 强一致性（一个副本变更，保证所有副本更新）
        - 分布式数据一致性工业级解决方案：
            - Zookeeper;
