## 目前系统应用架构演变，系统拆分
单机（all in one) 一》 MVC 一》 RPC 一》 SOA 一》 微服务/服务网格

互联网时代谈论最多的话题就是拆分，它是一种分而治之的思想和逻辑。
例如：前后端分离，无状态服务，RestFul通讯；按业务、实体、技术、数据、接口等拆分；
- 水平拆分：
    - 单一节点扩展为多节点，多节点具有一致的功能，组成一个服务池，节点共同处理大规模高并发的请求量。
- 垂直拆分：
    - 按功能拆分，即把一个复杂的功能拆分为多个单一简单的功能，更易于产品版本的迭代，还能够快速的进行敏捷发布和上线。


## 微服务
一种架构设计模式，属于 SOA（面向服务的架构）的一种形式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、互相配合，为用户提供最终价值。
    - 灵活（与编程开发语言无关，开发者可选择最适合业务，或自己最熟练的语言去完成业务逻辑的编写）
    - 微服务架构下服务拆分粒度更细，有利于资源重复（充分）利用，提高开发效率；
    - 微服务架构采用去中心化思想，服务之间采用RESTful等轻量级通信协议，相比ESB（企业服务总线）更轻量。
    - 在微服务系统架构下，开发者可以更加方便地制定每个服务的额优化方案，提高系统可维护性。也更适用于互联网时代的产品敏捷迭代开发。
备注：微服务设计其实是很早就有的设计思想，但随着虚拟化技术的崛起，微服务可以低成本的实现，所以也开始流行和兴起，微服务的内涵（自动化，去中心化，独立性等等）结合业务的特点，进行更好的选择

**快速响应、弹性伸缩**
- 针对特定服务发布，影响小，风险小，成本低
- 频繁发布版本，快速交付需求
- 低成本扩容，弹性伸缩，适应云环境
 
**带来的问题** ：
    - 增加系统的维护成本：拆分的服务实例如果过多，增加服务治理成本，不利于系统维护；
    - 增加系统的复杂性：服务之间相互依赖，有可能形成复杂的依赖链条，单个服务异常会引起服务都会受到影响，出现服务雪崩效应；
    - 增加系统的开发、部署成本：服务实例之间交互需要处理分布式事务、调用幂等和重试等问题，开发成本高，对团队挑战大；


使用Go语言实现，在性能，易用性，生态方面都具有优势！常用的微服务框架：Go Micro、Go Kit
    - 1、服务注册和发现（动态扩容，服务管理）
            - Consul、Etcd、Zookeeper
    - 2、远程服务调用（服务实例之间的交互通信）
            - 原生RPC、gRPC
            - 同步通信：HTTP、RPC；异步通信：消息队列
    - 3、分布式配置中心（管理分布式系统中各进程的动态配置、热加载）
            - Spring Cloud Config、Apollo、Disconf
    - 4、微服务网关（保护、增强和控制外部请求对于API服务的访问）
            - Nginx、Netfilx Zuul、Mashape Kong
    - 5、容错处理，负载均衡（提高服务的健壮性和容错能力：多实例部署间负载均衡，暂时性故障的重试、熔断、限流、降级机制）
            - 自定义负载均衡器、Hystrix
    - 6、统一认证和授权（多服务系统中对用户行为的统一认证和许可）
            - OAuth2、分布式Session、JWT
    - 7、分布式链路追踪（更直观分析请求链路和理解整个分布式系统、快速定位性能瓶颈、优化服务间依赖）
            - Twitter Zipkin、Uber jaeger、SkyWalking


## 分布式系统：
是一种系统部署方式，分布式是将一个系统拆分成多个子系统并分布到多个服务器上，但用户感知不到背后的逻辑，就像访问单个计算机一样。简单的说，是指将用户界面、控制台服务、数据库管理三个层次部署在不同的位置上。其中用户界面是客户端实现的功能，控制台服务是一个专门的服务器，数据管理是在一个专门的数据库服务器上实现的。
- 优点：
        - 解决集中式不便扩展的弊端，既可以针对应用进行硬扩展（性能水平扩展），也可以对应用进行软扩展（增加分布式缓存、消息队列、非关系型数据库等中间件），还一定程度上提供了业务隔离，就算一个应用出现问题也不会影响到别的应用。
- 缺点：
        - 增加了开发系统的复杂性：如分布式事务、分布式锁、分布式session、数据一致性等。
        - 增加了开发测试运维成本：工作量增加，分布式系统管理不好反而会变成一种负担。

分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。
由于网络硬件肯定会出现延迟丢包等问题，所以分区容错性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。

分布式锁的三种实现方式：基于数据库、Redis、ZooKeeper
ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。


## 工作中用到的一些架构方面的其它设计模式：
    - 单库单应用模式：最简单的，可能大家都见过
    - 内容分发模式：目前用的比较多
    - 查询分离模式：对于大并发的查询、业务
    - 微服务模式：适用于复杂的业务模式的拆解
    - 多级缓存模式：可以把缓存玩的很好
    - 分库分表模式：解决单机数据库瓶颈
    - 弹性伸缩模式：解决波峰波谷业务流量不均匀的方法之一
    - 多机房模式：解决高可用、高性能的一种方法
    https://www.cnblogs.com/ZenoLiang/p/10891499.html

## ServiceMesh(服务网格) ##
服务网格旨在解决开发人员在与远程端点通信时面临的许多挑战
https://zhuanlan.zhihu.com/p/153105848
https://www.jianshu.com/p/27a742e349f7


## 分布式锁的实现方案：	
	1、数据库实现（乐观锁）
	2、基于zookeeper的实现
	3、基于Redis的实现（推荐）；
