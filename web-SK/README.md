## Web相关知识 ##
Web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。是建立在Internet上的一种网络服务，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet上的信息节点组织成一个互为关联的网状结构。
B/S架构和C/S架构
B/S是基于网页语言的、与操作系统无关，跨平台，随着网页语言以及浏览器的进步，B/S在表现能力上的处理以及运行的速度上会越来越快，缺点将会越来越少。尤其是HTML5的普及，在图形的渲染方面以及音频、文件的处理上已经非常强大了.不过，C/S架构也有着不可替代的作用.



## 网络常见缩写 ##
**LAN：局部区域网**，局域网，本地网（全写为local area network）;

**DHCP：（动态主机配置协议）**是一个局域网的网络协议。

**VPN：（虚拟专用网络）**
通过一个公用互联网络建立的一个临时、安全、稳定隧道，使用这条隧道可以对数据进行几倍加密，主要使用在企业办公当中。

**ICMP：（因特网控制报文协议）**
TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。这些控制消息不传输用户数据，但是对于用户数据的传递起着重要的作用。ICMP报文有两种：差错报告报文和询问报文；

**RPC：（远程过程调用协议）**
是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式、多程序在内的应用程序更加容易。

**ARP：（地址解析协议）**
提供了网络层地址（IP地址）到物理地址（mac地址）之间的动态映射。网络层以上的协议用IP地址来标识网络接口，但以太数据帧传输时，以物理地址来标识网络接口。因此我们需要进行IP地址与物理地址之间的转化。

**API：（应用编程接口）**
是一些预先定义的函数，或指软件系统不同组成部分，衔接的约定。目的是提供 应用程序与开发人员 基于某软件或硬件 得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节。

**ORM：（对象关系映射）**
用于实现 面向对象编程语言里 不同类型系统的数据 之间的转换的 一种程序技术。
1.提高了开发效率。ORM可以自动对 实体对象 与数据库中的 表 进行字段与属性的映射，所以我们实际可能已经不需要一个专用的、庞大的数据访问层。
2.ORM提供了对数据库的映射，不用sql直接编码，能够像操作对象一样从数据库获取数据。

## 对websocket协议的认识。
是HTML5开始提供的一种 浏览器与服务器 间 进行 全双工通讯的网络技术。
Socket是TCP层的封装，浏览器和服务器只需要做一个握手的动作就可以实现数据的相互传送；

1、Header很小，信息传输效率高；2、服务器可以主动推送数据到浏览器；
3、socket长连接：指的是客户端和服务端之间保持一个socket连接长时间不断开，保持连接的情况下可以节省系统资源；

## 网络延时、完整性约束 ##
时延：是指一个报文或分组从一个网络（或一条链路）的一端传送到另一端所需的时间；
数据完整性约束：为了防止不符合规范的数据进入数据库，在用户对数据进行插入、修改、删除等操作时，DBMS自动按照一定的约束条件对数据进行监测，使不符合规范的数据不能进入数据库，以确保数据库中存储的数据正确、有效、相容；

## 脏数据 ##
脏数据：是指源系统中的数据 不在给定的范围内或对于实际业务毫无意义，或是数据格式非法，以及在源系统中存在不规范的编码和含糊的业务逻辑。
在数据库技术中,脏数据产生于临时更新（脏读）。例如：事务A更新了某个数据项X，由于某种原因事务A回滚。但是在回滚之前，另一个事务B读取了数据项X的值，A回滚了事务，数据项恢复了原值。事务B读取的就是数据项X的就是一个“临时”的值，就是脏数据。

## 单点登录：SSO（Single Sign On） ##

单点登录：是指在一个多系统共存的环境下，用户在一处登录后，就不用在其它系统中登录，也就是用户的一次登录就能得到其它所有系统的信任；对于大型系统来说使用单点登录可以减少用户很多的麻烦，多台主机负载均衡的话就涉及到session共享的问题

实现单点登录要解决如何产生和存储信任，再就是其它系统如何验证这个信任的有效性，因此要点有两个：
-存储信任   -验证信任
①以Cookie作为凭借媒介
②通过JSONP实现
③通过页面重定向的方式
④使用独立登录系统
 
## SSH：Secure Shell（安全外壳协议） ##
是建立在应用层基础上的安全协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH在正确使用时可弥补网络中的漏洞。

传统的网络服务程序，如：ftp、pop和telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据，非常容易就可以截获这些口令和数据。而且，这些服务程序的安全验证方式也是有其弱点的， 就是“中间人”可以冒充真正的服务器接收你传给服务器的数据，然后再冒充你把数据传给真正的服务器。服务器和你之间的数据传送被“中间人”一转手做了手脚之后，就会出现很严重的问题。

通过使用SSH，你可以把所有传输的数据进行加密，这样防止"中间人"这种攻击方式、DNS欺骗、IP欺骗。此外，使用SSH传输的数据是经过压缩的，还可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、PoP、甚至为PPP提供一个安全的"通道" 。

从客户端来看，SSH提供两种级别的安全验证：
基于口令的安全验证：只要你知道自己帐号和口令，就可以登录到远程主机。
基于密匙的安全验证：创建一对密匙，公用密匙放在需要访问的服务器上，保存自己密匙的口令，此种方法不需要在网络上传送口令。
第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒

## Html和css的关系 ##
单纯的html仅仅是静态文本，浏览器的渲染是基于html文档中各级标签内所定义的属性（<label style = 'fashion'>）以及外部css样式表来完成的。css样式表里面规定了html文档内部的所有元素对象（字体、线条、区块、表单、控件、菜单以及背景等）的表现形式（外观、粗细、颜色、背景色、间距等）。css通常以外部独立文件的形式嵌入在html头部标签（<head>）的script标签中。
浏览器在调用html文档时按照所加载的css样式表对整个页面完成渲染。

html与xml的语法一脉相承，但是html因为承担的角色比较特殊，所以它的结构体系有固定的模板，有大量常用的预定义标签，内部还需要嵌入css样式表，引用js动态脚本，看起来整个结构非常庞大。而xml则相当精简，适合用于单纯的数据存储与传输。


**网关：**，实质上是一个网络通向其他网络的IP地址。只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。网关的IP地址是 具有路由功能的设备 的IP地址，
具有路由功能的设备有：路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。

**DNS：域名服务器（DomainNameServer）**，在Internet上域名与IP地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务。
路由：连接多个网络或网段的网络设备，它能将不同网络或网段之间的数据信息进行“翻译”，以使它们能够相互“读”懂对方的数据，从而构成一个更大的网络。

## 端口号： ##
客户端可以通过IP地址找到对应的服务器端，但是服务器端是有很多 应用程序对应的 进程的，为了标识数据属于那个进程，把需要进行TCP通信的进程分配一个唯一的数字来标识它，这个数字就是我们常说的端口号。
端口和对应的服务：
21：FTP（文件传输协议）； 22：SSH；	23：Telnet（远程登录）服务；   25：SMTP（简单邮件传输协议）
53：DNS域名服务器、   
80：HTTP超文本传输协议  443：HTTPS；1080：Sockets

1521：Oracle数据库默认接口； 3306：MySQL服务


## Web常见响应状态码： ##
	1开头（状态信息）
	2开头（成功）
		200（OK）：请求成功，响应成功；
		202（Accepted）：已接受请求，尚未处理
		204（NoContent）：请求成功，且不需返回内容
	3开头（重定向）
		301（MovedPermanently）：被请求的资源已永久移动到新位置
		302（MovedTemporarily）：被请求的资源已临时移动到新位置
		302  重定向（未修改 请求的网页未修改，继续使用上次的资源）
		304  读的是缓存
	4开头（客户端错误）
		400 请求报文存在语法错误
		401 请求需要有认证信息
		403 访问被服务器拒绝
		404 服务器上没有找到请求的资源
		405 发送get/post...请求,没有对应的doGet/doPost...方法(没有重写父类的方法)
	5开头（服务器错误）
		500 服务器内部异常，无法完成请求（可能是用户权限，或者数据库连接，检查下服务器语句）
		502 网关错误，一般是服务器压力过大导致连接超时
		503 服务器宕机
		504 网关超时，服务器作为网关或代理，但是没有及时从上游服务器收到请求。 
	

## 序列化 ##
1、实现数据的持久化，把数据永久的保存到硬盘上；2、利用序列化实现远程通信，即在网络上传送对象的字节序列。
序列化和反序列化的过程就是生成和解析字符的过程；

Web应用程序是一个各种编程语言一个非常流行的应用领域；
它的后台开发涉及到的知识有：
1.模型设计：关系型数据库模型设计
2.SQL、ORM
3.Restful API设计


## Tcp粘包 ##
https://blog.csdn.net/weixin_30675247/article/details/95850314 
项目里的消息推送怎么做的（业务有关）

## 分布式事务 ##
在分布式部署的系统中几乎是必要的，它是恢复和并发控制的基本单位，具有4个属性，通常称为ACID特性。

- 原子性（atomicity）：一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。
- 一致性（consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。
- 隔离性（isolation）：一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
- 持久性（durability）：指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。

## 消息队列——基础问题
https://www.cnblogs.com/peteremperor/p/10273077.html

## 消息队列引入的问题
**1、系统复杂性**
使用的过程中还要考虑如，消息重复消费、消息丢失、消息的顺序消费等问题；包括对中间件消息队列自身的维护
（怎么防止重复消费（幂等性），说了借助Redis或者数据库的事务）

**2、数据一致性**
使用分布式事务：把下单，优惠券，积分...，等一系列操作，都放在一个事务里面一样，要成功一起成功，要失败一起失败。

**3、可用性**
如果系统本身没问题，接入的中间件在那万一挂了怎么办，怎么保证高可用？

## tomcat集群怎么保证同步 ##
集群的具体同步机制，tomcat共提供了两种：
**增量会话：**，是一种全节点复制模式，集群中一个节点发生改变后会同步到其余全部节点。（用于备份的网络流量会随着节点数的增加而急速增加，这也就是无法构建较大规模集群的原因）。非全节点复制：指的是集群中一个节点发生改变后，只同步到其余一个或部分节点。除了这一特点，集群增量会话管理器还具有只同步会话增量的特点，增量是以一个完整请求为周期，也就是说会在一个请求被响应之前同步到其余节点上。
**备份会话：**，为了解决全节点复制模式存在的问题就是，tomcat提出了集群备份会话管理器，每个会话只有一个备份，这样就可构建大规模的集群。

同步组件：在上述无论是发送还是接收信息的过程中，使用到的组件主要有三个：Manager, Cluster, tribes。
Manager的作用是将操作的信息记录下来，然后序列化后交给Cluster，接着Cluster是依赖于tribes将信息发送出去的。其余节点收到信息后，按照相反的流程一步步传到Manager，经过反序列化之后使该节点同步传递过来的操作信息。

## Post和Get区别？ ##
- 1.get重点在从服务器上获取资源，post重点在向服务器发送数据；
- 2.Get传输的数据量小，受URL长度限制，但效率较高；Post可以传输大量数据，所以上传文件时只能用Post方式；
- 3.get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；post较get安全性较高；
- 4.get方式只支持ASCII字符，向服务器传的中文字符可能会乱码；post支持标准字符集，可以正确传递中文字符。
在客户端get方式通过URL提交数据，数据在URL中可以看到；以field（字段）=value的形式，置于URL后，并用"?"连接，多个请求数据间用"&"连接，如http：//127.0.0.1/Test/login.action? name=admin &password =admin；

## get跟head
HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。

## http keep-alive
client发出的HTTP请求头需要增加Connection:keep-alive字段
Web-Server端要能识别Connection:keep-alive字段，并且在http的response里指定Connection:keep-alive字段，告诉client，我能提供keep-alive服务，并且"应允"client我暂时不会关闭socket连接

## Cookie和Session区别？ ##
1.都是会话技术，Cookie是运行在客户端，Session是运行在服务器端。
2.在浏览器Cookie有大小及个数的限制，Session是没有大小限制和它和服务器的内存大小有关。
3.Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击。
4.Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。

Cookie通过客户端（浏览器）来缓存个人信息，将个人的账号和密码存起来，在下一次访问服务器的时候会带上该Cookie用来个人信息进行验证。解决这个问题的就是Cookie和Session；
Session：当你第一次访问服务器的时候，服务器会在内存中开辟一块空间，返回唯一一把打开该空间的钥匙，再把这把钥匙返回到浏览器；当你第二次访问的时候浏览器会携带这把钥匙到服务器端打开对应的空间，如果该空间已经销毁，重新开辟一块新的空间返回新的钥匙到浏览器。
Session和Cookie：Session的运行依赖Session id，而Session id是存在cookie中的，所以如果浏览器禁用了cookie，同时session也会失效，存储Session时，键与Cookie中的session id相同，值是开发人员设置的键值对信息，进行了base64编码，过期时间由开发人员设置；