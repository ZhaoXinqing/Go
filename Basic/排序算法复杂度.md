## 排序算法复杂度

![img](https:////upload-images.jianshu.io/upload_images/7423808-bc478d8da959bf89.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

**希尔排序**是 直接插入的**优化**，直接插入排序在基本有序时，时间复杂度**接近**`O(n)`，希尔排序按照由`n~1`的**分组策略**，将数据集初期拆解成**较小的子集**，这时候使用直接插入排序O(n)和O(n^2)的复杂度区别不大，而当子集分组为1时，整个集合已经**基本有序**，这一趟基本趋向于O(n)，适用于**`中等规模`**的数据集



**归并排序** 采用了**分治**的方法，`自顶向下(二分查找法后做合并)`

排序算法的**稳定性**大家应该都知道，通俗地讲就是能保证**排序前**`2个相等`的数其在`序列`的**前后位置顺序**和`排序后`它们两个的**前后位置**顺序`相同`。在简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前
 [稳定性分析](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fyangnianjinxin%2Farticle%2Fdetails%2F77918882)

### 1. 简单规则 时间复杂度

1. 有限次操作 `O(1)`
2. for循环 `O(n)`
3. 树的高度 `O(log(n))`
    BS复杂度是 `O(log(n))` 减治法

```cpp
int BS(int[]arr, int low, inthigh, int target){
         if(low> high) return -1;
         mid= (low+high)/2;
         if(arr[mid]== target) return mid;
         if(arr[mid]> target)
                   return BS(arr, low, mid-1, target);
         else
                   return BS(arr, mid+1, high, target);
}
```

Heap复杂度是`O(lg(n))`

### 2. 组合规则 时间复杂度

1. 冒泡排序
    O(n) * O(n) * O(1) = `O(n^2)`
2. topK

```kotlin
// 制作堆 O(k)
heap[k] = make_heap(arr[1, k]);
// 循环n次 O（n）
for(i=k+1 to n){
         // 对堆做调整 O(lg(n))
         adjust_heap(heap[k],arr[i]);
}
return heap[k];
```

O(k) + O(n)*O(lg(k)) = `O(n * log(k))`

### 3. 递归求解

1. 先得出常量 **f(1) = 1**
2. 再求出**后续公式**，分治 f(n) = 1 + f(n-1)
3. 将f(1) 代入公式可以**求出通解**

**快排**复杂度是 `O(n*log(n))`，但是要使用**辅助栈**

```java
void quick_sort(int[]arr, int low, inthigh){
         if (low>=high) return;
         // for找出中间值，O(logn)
         int i = partition(arr, low, high);
         // f(n/2) - 分治左
         quick_sort(arr, low, i-1);
         // f(n/2) - 分治右
         quick_sort(arr, i+1, high);
}
private int partition(int[] nums, int lo, int hi) {
        int p=nums[lo];
        while(lo<hi) {
            while(lo<hi && p<=nums[hi]) hi--;
            nums[lo]=nums[hi];
            while(lo<hi && p>=nums[lo]) lo++;
            nums[hi]=nums[lo];
        }
        nums[lo]=p;
        return lo;
    }
```

### 4. 分治与减治

- **分治法**，`每个`分支`都要`递归，例如：**快速排序** `O(n*log(n))`
- **减治法**，`只要`递归`一个`分支，例如：**二分查找** `O(log(n))`，**随机选择** `O(n)`
- `O(分治法)` **>** `O(减治法)`

**随机选择/快速选择算法**减治法

```kotlin
int RS(arr, low, high, k){
  if(low== high) return arr[low];
  i= partition(arr, low, high);
  temp= i-low; //数组前半部分元素个数
  if(temp>=k)
      return RS(arr, low, i-1, k); //求前半部分第k大
  else
      return RS(arr, i+1, high, k-i); //求后半部分第k-i大
}
```

### 5. 斐波那契数列

1. **从大到小递归**，尽可能不要使用**递归**，会有大量栈，容易跑死机
2. 正推法，使用 `f(n) = f(n-1) + f(n-2)` **从小到大累加** `O(n)`

### 6. 正整数的二进制表示包含多少个1

1. 根据整数的位数m，每次`n>>=1`，`n&1==1`说明存在一个1，`O(m)`
2. `n&(n-1)`这个操作，可以起到**消除最后一个1**的功效， O(m/2)

```bash
while(n){
   result++;
   n&=(n-1);
}
```

### 6. 堆

**大顶堆** 子节点都**小于**父节点
 **小顶堆**子节点都**大于**父节点

### 7. 计数排序

当输入的元素是 `n` 个 `0到 k` 之间的整数时，时间复杂度是`O(n+k)`，空间复杂度也是`O(n+k)`，其排序速度快于任何比较排序算法
 当**k不是很大**并且序列**比较集中**时，计数排序是一个很有效的排序算法

### 8. 桶排序 Bucket Sort

先将数据放置在对应的桶中（桶内暂时是无序），在排序的时候，对桶内数据做**插入排序**
 桶排序最好情况下使用线性时间`O(n)`，桶排序的时间复杂度，取决与对各个桶之间数据进行`排序的时间复杂度`

### 9. 基数排序 Radix Sort

从个位开始，先排序放置在对应的额外空间，再按顺序放置回原数组，再从十位依次类推
 基数排序的空间复杂度为`O(d*2n)`d较小，约等于 `O(n+k)`，其中k为桶的数量。一般来说n>>k，因此额外空间需要大概`n`个左右

### 10. 红黑树

红黑树大多数的操作所需要的时间都是对数级别的 O(logn)
 平衡树的插入和删除的时间复杂度



作者：哓晓的故事
链接：https://www.jianshu.com/p/95bff468978d
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。