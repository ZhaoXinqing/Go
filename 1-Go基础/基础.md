base-golang


## Go流程控制方法

- if - else 条件语句
- switch - case 选择语句
- for - range 循环语句
- goto 无条件跳转语句
- defer 延迟语句

case 使用关键字 `fallthrough` 可以开启穿透，但只能穿透一层，意思是它只给你一次再判断case的机会，不管你有没有匹配上，都要退出了。纠正：【fallthrough是无条件执行下一个case的内容，而不是新增一次判断case的机会】



## new / make  函数


new：为所有的类型分配内存，并初始化为零值，返回指针。
make：只能为 slice，map，chan 分配内存，并初始化，返回的是类型。
另外，目前来看 new 函数并不常用，大家更喜欢使用短语句声明的方式。

```go
a := new(int)
a = 1
// 等价于
a := 1
```

但是 make 就不一样了，它的地位无可替代，在使用slice、map以及channel的时候，还是要使用make进行初始化，然后才可以对他们进行操作。



## 使用信道和WaitGroup实现并发

**1、使用信道来标记完成**

信道可以实现多个协程间的通信，那么我们只要定义一个信道，在任务完成后，往信道中写入true，然后在主协程中获取到true，就认为子协程已经执行完毕。

```go
import "fmt"
func main() {
    done := make(chan bool)
    go func() {
        for i := 0;i<5;i++ {
            fmt.Println(i)
        }
        done <- true
    }()
    <- done
}
```

**2、使用WaitGroup**

用信道的方法，在单个协程或者协程数少的时候，并不会有什么问题，但在协程数多的时候，代码就会显得非常复杂，更加优雅的方式，使用sync包 提供的 WaitGroup 类型。

WaitGroup  你只要实例化了就能使用，`var 实例名 sync.WaitGroup` ，它的几个方法：

- `Add`：初始值为0，你传入的值会往计数器上加，这里直接传入你子协程的数量
- `Done`：当某个子协程完成后，可调用此方法，会从计数器上减一，通常可以使用 defer 来调用。
- `Wait`：阻塞当前协程，直到实例里的计数器归零。

```go
import (
	"fmt"
    "sync"
)
unbtqyabiwojhgee
func worker(x int,wg *sync.WaitGroup) {
    defer wg.Done()
    for i := 0;i < 5;i++ {
        fmt.Printf("worker %d: %d\n",x,i)
    }
}

func main() {
    var wg sync.WaitGroup
    
    wg.Add(2)
    go worker(1,&wg)
    go worker(2,&wg)
    
    wg.Wait()
}
```



## select

select 与 switch 原理很相似，但它的使用场景更特殊，学习了本篇文章，你需要知道如下几点区别：

1. select 只能用于 channel 的操作(写入/读出)，而 switch 则更通用一些；
2. select 的 case 是随机的，而 switch 里的 case 是顺序执行；
3. select 要注意避免出现死锁，同时也可以自行实现超时机制；
4. select 里没有类似 switch 里的 fallthrough 的用法；
5. select 不能像 switch 一样接函数或其他表达式。

select 里的 case 表达式只要求你是对信道的操作即可，不管你是往信道写入数据，还是从信道读出数据。



## Context

Context，也叫上下文，它的接口定义如下

```go
type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key interface{}) interface{}
}
```

可以看到 Context 接口共有 4 个方法

- `Deadline`：返回的第一个值是 **截止时间**，到了这个时间点，Context 会自动触发 Cancel 动作。返回的第二个值是 一个布尔值，true 表示设置了截止时间，false 表示没有设置截止时间，如果没有设置截止时间，就要手动调用 cancel 函数取消 Context。
- `Done`：返回一个只读的通道（只有在被cancel后才会返回），类型为 `struct{}`。当这个通道可读时，意味着parent context已经发起了取消请求，根据这个信号，开发者就可以做一些清理动作，退出goroutine。
- `Err`：返回 context 被 cancel 的原因。
- `Value`：返回被绑定到 Context 的值，是一个键值对，所以要通过一个Key才可以获取对应的值，这个值一般是线程安全的。

```go
package main

import (
	"context"
    "fmt"
    "time"
)

func monitor(ctx context.Context, number int) {
    for {
        select {
        case v := <- ctx.Done():
            fmt.Printf("监控器%v,正在监控中。。。\n",number,v)
            return
        default:
            fmt.Printf("监控器%v,正在监控中...\n", number)
            time.Sleep(2 * time.Second)
        }
    }
}

func main() {
    ctx,cancel := context.WithCancel(context.Background())
    
    for i := 1; i <= 5; i++ {
        go monitor(ctx,i)
    }
    time.Sleep( 1 * time.Second)
    // 关闭所有 goroutine
    cancel()
    
    // 等待5s，若此时屏幕没有输出<正在监控> 就说明说有的goroutine都已经关闭了
    time.Sleep( 5 * time.Second)
    fmt.Println("主程序退出！！")
}
```

这里面的关键代码，也就三行

第一行：以 context.Background() 为 parent context 定义一个可取消的 context

```
ctx, cancel := context.WithCancel(context.Background())
```

第二行：然后你可以在所有的goroutine 里利用 for + select 搭配来不断检查 ctx.Done() 是否可读，可读就说明该 context 已经取消，你可以清理 goroutine 并退出了。

```
case <- ctx.Done():
```

第三行：当你想到取消 context 的时候，只要调用一下 cancel 方法即可。这个 cancel 就是我们在创建 ctx 的时候返回的第二个值。

```
cancel()
```

##  Context 使用注意事项

1. 通常 Context 都是做为函数的第一个参数进行传递（规范性做法），并且变量名建议统一叫 ctx
2. Context 是线程安全的，可以放心地在多个 goroutine 中使用。
3. 当你把 Context 传递给多个 goroutine 使用时，只要执行一次 cancel 操作，所有的 goroutine 就可以收到 取消的信号
4. 不要把原本可以由函数参数来传递的变量，交给 Context 的 Value 来传递。
5. 当一个函数需要接收一个 Context 时，但是此时你还不知道要传递什么 Context 时，可以先用 context.TODO 来代替，而不要选择传递一个 nil。
6. 当一个 Context 被 cancel 时，继承自该 Context 的所有 子 Context 都会被 cancel。