## 1、数据类型：byte、rune与string

**byte**，占用1个节字，就 8 个比特位，所以它和 `uint8` 类型本质上没有区别，它表示的是 ACSII 表中的一个字符。

**rune**，占用4个字节，共32位比特位，所以它和 `uint32` 本质上也没有区别。它表示的是一个 Unicode字符（Unicode是一个可以表示世界范围内的绝大部分字符的编码规范）。

由于 byte 类型能表示的值是有限，只有 2^8=256 个。所以如果你想表示中文的话，你只能使用 rune 类型。

`var a byte = 'a', var b rune = 'b'`

在定义字符时，不管是 byte 还是 rune ，我都是使用单引号，**在 Go 中单引号与 双引号并不是等价的**。单引号用来表示字符，双引号，就意味着你要定义一个字符串。

因为uint8 和 uint32 ，直观上让人以为这是一个数值，但是实际上，它也可以表示一个字符，所以为了消除这种直观错觉，就诞生了 byte 和 rune 这两个别名类型。

**string**，byte 和 rune 都是字符类型，若多个字符放在一起，就组成了字符串，也就是这里要说的 string 类型，string 的本质，其实是一个 byte数组

Go 语言的 string 是用 uft-8 进行编码的，英文字母占用一个字节，而中文字母占用 3个字节，所以 `hello,中国` 的长度为 5+1+（3＊2)= 12个字节。



## Go流程控制方法

- if - else 条件语句
- switch - case 选择语句
- for - range 循环语句
- goto 无条件跳转语句
- defer 延迟语句

case 使用关键字 `fallthrough` 可以开启穿透，但只能穿透一层，意思是它只给你一次再判断case的机会，不管你有没有匹配上，都要退出了。纠正：【fallthrough是无条件执行下一个case的内容，而不是新增一次判断case的机会】



## 1. new  函数

在官方文档中，new 函数的描述如下

> // The new built-in function allocates memory. The first argument is a type,
> // not a value, and the value returned is a pointer to a newly
> // allocated zero value of that type.
> func new(Type) *Type

可以看到，new 只能传递一个参数，该参数为一个任意类型，可以是Go语言内建的类型，也可以是你自定义的类型

那么 new 函数到底做了哪些事呢：

- 分配内存
- 设置零值
- 返回指针（重要）

举个例子

```go
import "fmt"

type Student struct {
   name string
   age int
}

func main() {
    // new 一个内建类型
    num := new(int)
    fmt.Println(*num) //打印零值：0

    // new 一个自定义类型
    s := new(Student)
    s.name = "wangbm"
}
```

## 2. make 函数

在官方文档中，make 函数的描述如下

> //The make built-in function allocates and initializes an object
> //of type slice, map, or chan (only). Like new, the first argument is
> // a type, not a value. Unlike new, make's return type is the same as
> // the type of its argument, not a pointer to it.
>
> func make(t Type, size …IntegerType) Type

翻译一下注释内容

1. 内建函数 make 用来为 slice，map 或 chan 类型（注意：也只能用在这三种类型上）分配内存和初始化一个对象
2. make 返回类型的本身而不是指针，而返回值也依赖于具体传入的类型，因为这三种类型（slice，map 和 chan）本身就是引用类型，所以就没有必要返回他们的指针了

由于这三种类型都是引用类型，所以必须得初始化（size和cap），但是不是置为零值，这个和new是不一样的。

举几个例子

```go
//切片
a := make([]int, 2, 10)  

// 字典
b := make(map[string]int)

// 通道
c := make(chan int, 10)
```

## 3. 总结

new：为所有的类型分配内存，并初始化为零值，返回指针。
make：只能为 slice，map，chan 分配内存，并初始化，返回的是类型。
另外，目前来看 new 函数并不常用，大家更喜欢使用短语句声明的方式。

```go
a := new(int)
a = 1
// 等价于
a := 1
```

但是 make 就不一样了，它的地位无可替代，在使用slice、map以及channel的时候，还是要使用make进行初始化，然后才可以对他们进行操作。



## 使用信道和WaitGroup实现并发

**1、使用信道来标记完成**

信道可以实现多个协程间的通信，那么我们只要定义一个信道，在任务完成后，往信道中写入true，然后在主协程中获取到true，就认为子协程已经执行完毕。

```go
import "fmt"
func main() {
    done := make(chan bool)
    go func() {
        for i := 0;i<5;i++ {
            fmt.Println(i)
        }
        done <- true
    }()
    <- done
}
```

**2、使用WaitGroup**

用信道的方法，在单个协程或者协程数少的时候，并不会有什么问题，但在协程数多的时候，代码就会显得非常复杂，更加优雅的方式，使用sync包 提供的 WaitGroup 类型。

WaitGroup  你只要实例化了就能使用，`var 实例名 sync.WaitGroup` ，它的几个方法：

- `Add`：初始值为0，你传入的值会往计数器上加，这里直接传入你子协程的数量
- `Done`：当某个子协程完成后，可调用此方法，会从计数器上减一，通常可以使用 defer 来调用。
- `Wait`：阻塞当前协程，直到实例里的计数器归零。

```go
import (
	"fmt"
    "sync"
)

func worker(x int,wg *sync.WaitGroup) {
    defer wg.Done()
    for i := 0;i < 5;i++ {
        fmt.Printf("worker %d: %d\n",x,i)
    }
}

func main() {
    var wg sync.WaitGroup
    
    wg.Add(2)
    go worker(1,&wg)
    go worker(2,&wg)
    
    wg.Wait()
}
```



## select

select 与 switch 原理很相似，但它的使用场景更特殊，学习了本篇文章，你需要知道如下几点区别：

1. select 只能用于 channel 的操作(写入/读出)，而 switch 则更通用一些；
2. select 的 case 是随机的，而 switch 里的 case 是顺序执行；
3. select 要注意避免出现死锁，同时也可以自行实现超时机制；
4. select 里没有类似 switch 里的 fallthrough 的用法；
5. select 不能像 switch 一样接函数或其他表达式。

select 里的 case 表达式只要求你是对信道的操作即可，不管你是往信道写入数据，还是从信道读出数据。



## Context

Context，也叫上下文，它的接口定义如下

```go
type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key interface{}) interface{}
}
```

可以看到 Context 接口共有 4 个方法

- `Deadline`：返回的第一个值是 **截止时间**，到了这个时间点，Context 会自动触发 Cancel 动作。返回的第二个值是 一个布尔值，true 表示设置了截止时间，false 表示没有设置截止时间，如果没有设置截止时间，就要手动调用 cancel 函数取消 Context。
- `Done`：返回一个只读的通道（只有在被cancel后才会返回），类型为 `struct{}`。当这个通道可读时，意味着parent context已经发起了取消请求，根据这个信号，开发者就可以做一些清理动作，退出goroutine。
- `Err`：返回 context 被 cancel 的原因。
- `Value`：返回被绑定到 Context 的值，是一个键值对，所以要通过一个Key才可以获取对应的值，这个值一般是线程安全的。

```go
package main

import (
	"context"
    "fmt"
    "time"
)

func monitor(ctx context.Context, number int) {
    for {
        select {
        case v := <- ctx.Done():
            fmt.Printf("监控器%v,正在监控中。。。\n",number,v)
            return
        default:
            fmt.Printf("监控器%v,正在监控中...\n", number)
            time.Sleep(2 * time.Second)
        }
    }
}

func main() {
    ctx,cancel := context.WithCancel(context.Background())
    
    for i := 1; i <= 5; i++ {
        go monitor(ctx,i)
    }
    time.Sleep( 1 * time.Second)
    // 关闭所有 goroutine
    cancel()
    
    // 等待5s，若此时屏幕没有输出<正在监控> 就说明说有的goroutine都已经关闭了
    time.Sleep( 5 * time.Second)
    fmt.Println("主程序退出！！")
}
```

这里面的关键代码，也就三行

第一行：以 context.Background() 为 parent context 定义一个可取消的 context

```
ctx, cancel := context.WithCancel(context.Background())
```

第二行：然后你可以在所有的goroutine 里利用 for + select 搭配来不断检查 ctx.Done() 是否可读，可读就说明该 context 已经取消，你可以清理 goroutine 并退出了。

```
case <- ctx.Done():
```

第三行：当你想到取消 context 的时候，只要调用一下 cancel 方法即可。这个 cancel 就是我们在创建 ctx 的时候返回的第二个值。

```
cancel()
```

##  Context 使用注意事项

1. 通常 Context 都是做为函数的第一个参数进行传递（规范性做法），并且变量名建议统一叫 ctx
2. Context 是线程安全的，可以放心地在多个 goroutine 中使用。
3. 当你把 Context 传递给多个 goroutine 使用时，只要执行一次 cancel 操作，所有的 goroutine 就可以收到 取消的信号
4. 不要把原本可以由函数参数来传递的变量，交给 Context 的 Value 来传递。
5. 当一个函数需要接收一个 Context 时，但是此时你还不知道要传递什么 Context 时，可以先用 context.TODO 来代替，而不要选择传递一个 nil。
6. 当一个 Context 被 cancel 时，继承自该 Context 的所有 子 Context 都会被 cancel。