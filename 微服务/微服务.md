## 什么是微服务？ ##

1. 是一种软件开发技术，属于 SOA（面向服务的架构）的一种形式。
1. “微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、互相配合，为用户提供最终价值。
1. 每个服务运行在其独立的进程中，服务和服务之间采用轻量级的通信机制相互沟通，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。
1. 针对具体的每一个服务，可以根据业务上下文，选择合适的语言、工具对其进行构建"   

## 为什么抛弃单体架构选择微服务？ ##

- 部署成本高（无论是修改1行代码，还是10行代码，都要全量替换）
- 改动影响大，风险高（不论代码改动多小，成本都相同）
- 因为成本高，风险高，所以导致部署频率低（无法快速交付客户需求）

当然还有例如无法满足快速扩容，弹性伸缩，无法适应云环境特性等问题，而以上的问题，都是微服务架构要解决的问题

## 微服务解决什么问题，又引入了什么问题？ ##
我们先看看微服务能 **带给我们什么** ？微服务架构的特点：

- 针对特定服务发布，影响小，风险小，成本低
- 频繁发布版本，快速交付需求
- 低成本扩容，弹性伸缩，适应云环境
 

我们知道一个朴素的理念，没有任何事物是完美的，任何东西都有两面性，有得必有失，那么在选择微服务在解决了快速响应和弹性伸缩的问题同时，它又给我们 **带来了什么问题** ？个人总结如下：

- 分布式系统的复杂性
- 部署，测试和监控的成本问题
- 分布式事务和CAP的相关问题

系统应用由原来的单体变成几十到几百个不同的工程，会所产生例如包括服务间的依赖，服务如何拆封，内部接口规范，数据传递等等问题，尤其是服务拆分，需要团队熟悉业务流程，懂得取舍，要保证拆分的粒度服务既符合“高内聚，低耦合”的基本原则，还要兼顾业务的发展以及公司的愿景，要还要说服团队成员为之努力，并且积极投入，在多方中间取得平衡。

对于分布式系统，部署，测试和监控都需要大量的中间件来支撑，而且中间件本身也要维护，原先单体应用很简单的事务问题 ，转到分布式环境就变得很复杂，分布式事务是采用简单的重试+补偿机制，还是采用二阶段提交协议等强一致性方法来解决，就要取决对业务场景的熟悉加上反复的权衡了，相同问题还包括对 CAP 模型的权衡，总之微服务对团队整体的技术栈水平整体要求更高

## 微服务技术总结 ##
微服务设计其实是很早就有的设计思想，因为随着虚拟化技术的崛起，微服务可以低成本的实现，所以也开始流行和兴起。

微服务的内涵很深，其中就包括，自动化，去中心化，独立性等等，其中细节无法用一篇文章概述清楚，我们在做技术选型或者方案的时候，尽可能多去了解技术的本身和起源再结合我们业务的特点，进行更好的选


## 为什么使用 go 构建微服务？ ##
虽然 Golang 是一门新的语言，但是与其他语言相比，它有很多优势。用 Golang 编写的程序更加健壮。它们能够承受程序使用运行的服务构建的繁重负载。Golang 更适合多处理器系统和 web 应用程序。此外，它容易地与 GitHub 集成，管理非集中的代码包。微服务架构的用处大部分体现在当程序需要伸缩（scalable)时。如果有一种语言可以完全符合标准,那么它就是 Golang。原因是它继承自 C-family 编程语言，用 Golang 编写的组件更容易与同一家族中其他语言编写的组件相结合。

1. 尽管 Go 出身于 C-family，但它比 C / C ++更高效。它语法更简单，有点像 Python。
1. 它稳定语法, 自第一次公开发布以来，它没有太大变化，也就是说它是后向兼容的。与其他语言相比，这让 golang 占了上风。
1. 除此之外，Golang 的性能比 python 和 java 高出不少。锦上添花的是，它又像 C/C++ 简单的同时又易于阅读和理解，使它成为开发微服务应用的绝佳选择。
 
## 微服务框架至少要包括那些技术 ##

### 2.1 监控 - 发现故障的征兆 ###
在高并发分布式的场景下，故障经常是突然间就雪崩式爆发。所以必须建立完善的监控体系，尽可能发现故障的征兆。
微服务架构中组件繁多，各个组件所需要监控的指标不同。
比如Redis缓存一般监控占用内存值、网络流量，数据库监控连接数、磁盘空间，业务服务监控并发数、响应延迟、错误率等。因此如果做一个大而全的监控系统来监控各个组件是不大现实的，而且扩展性会很差。
一般的做法是让各个组件提供报告自己当前状态的接口（metrics接口），这个接口输出的数据格式应该是一致的。
然后部署一个指标采集器组件，定时从这些接口获取并保持组件状态，同时提供查询服务。最后还需要一个UI，从指标采集器查询各项指标，绘制监控界面或者根据阈值发出告警。
 
### 2.2 定位问题 - 链路跟踪 ###
在微服务架构下，一个用户的请求往往涉及多个内部服务调用。为了方便定位问题，需要能够记录每个用户请求时，微服务内部产生了多少服务调用，及其调用关系。这个叫做链路跟踪。
要实现链路跟踪，每次服务调用会在HTTP的HEADERS中记录至少记录四项数据：

- traceId：traceId标识一个用户请求的调用链路。具有相同traceId的调用属于同一条链路。
- spanId：标识一次服务调用的ID，即链路跟踪的节点ID。
- parentId：父节点的spanId。
- requestTime & responseTime：请求时间和响应时间。

链路跟踪只能定位到哪个服务出现问题，不能提供具体的错误信息。查找具体的错误信息的能力则需要由日志分析组件来提供。

### 2.3 分析问题 - 日志分析 ###
日志分析组件在微服务兴起之前就被广泛使用了。
即使单体应用架构，当访问数变大、或服务器规模增多时，日志文件的大小会膨胀到难以用文本编辑器进行访问，更糟的是它们分散在多台服务器上面。排查一个问题，需要登录到各台服务器去获取日志文件，一个一个地查找（而且打开、查找都很慢）想要的日志信息。
因此，在应用规模变大时，我们需要一个日志的“搜索引擎”。以便于能准确的找到想要的日志。另外，数据源一侧还需要收集日志的组件和展示结果的UI组件：
日志服务可以使用ELK日志分析组件。ELK是Elasticsearch、Logstash和Kibana三个组件的缩写。

- Elasticsearch：搜索引擎，同时也是日志的存储。
- Logstash：日志采集器，它接收日志输入，对日志进行一些预处理，然后输出到Elasticsearch。
- Kibana：UI组件，通过Elasticsearch的API查找数据并展示给用户。
 
### 2.4 网关 - 权限控制，服务治理 ###

拆分成微服务后，出现大量的服务，大量的接口，使得整个调用关系乱糟糟的。经常在开发过程中，写着写着，忽然想不起某个数据应该调用哪个服务。或者写歪了，调用了不该调用的服务。

为了应对这些情况，微服务的调用需要一个把关的东西，也就是网关。在调用者和被调用者中间加一层网关，每次调用时进行权限校验。另外，网关也可以作为一个提供服务接口文档的平台。

使用网关有一个问题就是要决定在多大粒度上使用：最粗粒度的方案是整个微服务一个网关，微服务外部通过网关访问微服务，微服务内部则直接调用；

最细粒度则是所有调用，不管是微服务内部调用或者来自外部的调用，都必须通过网关。折中的方案是按照业务领域将微服务分成几个区，区内直接调用，区间通过网关调用。
 
### 2.5 服务注册与发现 - 动态扩容 ###

解决这个问题的方案是服务自动注册与发现。
首先，需要部署一个服务发现服务，它提供所有已注册服务的地址信息的服务。DNS也算是一种服务发现服务。然后各个应用服务在启动时自动将自己注册到服务发现服务上。并且应用服务启动后会实时（定期）从服务发现服务同步各个应用服务的地址列表到本地。
服务发现服务也会定期检查应用服务的健康状态，去掉不健康的实例地址。这样新增实例时只需要部署新实例，实例下线时直接关停服务即可，服务发现会自动检查服务实例的增减。
 
服务发现还会跟客户端负载均衡配合使用。由于应用服务已经同步服务地址列表在本地了，所以访问微服务时，可以自己决定负载策略。
甚至可以在服务注册时加入一些元数据（服务版本等信息），客户端负载则根据这些元数据进行流量控制，实现A/B测试、蓝绿发布等功能。
服务发现有很多组件可以选择，比如说Zookeeper 、Eureka、Consul、Etcd等，也可以开发者自己通过Redis实现。
 
### 2.6 熔断、服务降级、限流 ###

**服务熔断**：当一个服务因为各种原因停止响应时，调用方通常会等待一段时间，然后超时或者收到错误返回。如果调用链路比较长，可能会导致请求堆积，整条链路占用大量资源一直在等待下游响应。
所以当多次访问一个服务失败时，应熔断，标记该服务已停止工作，直接返回错误。直至该服务恢复正常后再重新建立连接。

**服务降级**：当下游服务停止工作后，如果该服务并非核心业务，则上游服务应该降级，以保证核心业务不中断。比如网上超市下单界面有一个推荐商品凑单的功能，当推荐模块挂了后，下单功能不能一起挂掉，只需要暂时关闭推荐功能即可。

**服务限流**：一个服务挂掉后，上游服务或者用户一般会习惯性地重试访问。这导致一旦服务恢复正常，很可能因为瞬间网络流量过大又立刻挂掉，在棺材里重复着仰卧起坐。因此服务需要能够自我保护——限流。
限流策略有很多，最简单的比如当单位时间内请求数过多时，丢弃多余的请求。另外，也可以考虑分区限流。仅拒绝来自产生大量请求的服务的请求。
例如商品服务和订单服务都需要访问促销服务，商品服务由于代码问题发起了大量请求，促销服务则只限制来自商品服务的请求，来自订单服务的请求则正常响应。


## Golang中的微服务架构框架 ##

### Go Micro ###
Go Micro 是目前为止我遇到的最流行的RPC框架。它是一个可插拔的RPC框架。Go Micro 为我们提供了以下功能:

- 服务发现: 程序自动注册到服务发现系统
- 负载均衡: 它提供了客户端负载均衡，这有助于平衡服务实例之间的请求
- 同步通信: 提供 Request/Response 传输层
- 异步通信: 具有内置的发布和订阅功能
- 消息编码: 可以利用 header 中 Content-Type 进行编码和解码
- RPC客户端/服务器端: 利用上述功能并提供构建微服务需要的接口

![](https://camo.githubusercontent.com/9057599d2bc2d3c79c43423521d71f4ea0851457/68747470733a2f2f6d6963726f2e6d752f646f63732f696d616765732f676f2d6d6963726f2e737667)
[图片](https://camo.githubusercontent.com/9057599d2bc2d3c79c43423521d71f4ea0851457/68747470733a2f2f6d6963726f2e6d752f646f63732f696d616765732f676f2d6d6963726f2e737667)

Go Micro 架构由三层组成。第一层抽象为服务层。第二层为 client-server 模型层。serrver 用于编写服务的块组成，而 client 为我们提供接口，其唯一目的是向 server model 中编写的服务发出请求。

第三层有以下类型的插件:

- Broker: 在异步通信中为 message broker(消息代理）提供接口
- Codec: 用于加密或解密消息
- Registry: 提供服务搜索功能
- Selector: 在 register 上构建了负载均衡
- Transport: Transport是服务与服务之间同步请求/响应的通信接口

它还提供了一个名为 Sidecar 的功能。Sidecar 使您能够集成以Go以外的语言编写的服务。它还为我们提供了gRPC编码/解码、服务注册和HTTP 请求处理

### GO Kit ###

Go Kit 是一个用于构建微服务的编程工具包。与 Go Micro不同，它是一个可以以二进制包导入的库。Go Kit 规则很简单。如下:

- 没有全局变量
- 声明式组合
- 显式依赖
- Interface as Contracts (接口合约)
- 领域驱动设计（DDD)


Go Kit 提供以下代码包:

Authentication 鉴权: BasicAuth 和 JWT
Transport 协议: HTTP, gRPC 等
Logging 日志: 服务中的结构化日志接口
Metrics 度量: CloudWatch,Statsd, Graphite等
Tracing 分布式追踪: Zipkin and Opentracing
Service discovery 服务发现: Consul, Etcd, Eureka等
Circuitbreaker 限流熔断: Hystrix 在 Go 语言的实现
Go Kit 服务架构如下


### Kite ###
Kite 是一个在 Go 中开发微服务的框架。它公开RPC client 和 Server 端代码包。创建的服务将自动注册到服务发现系统 Kontrol。Kontrol 是用 Kite 编写的，它本身就是一个 Kite service。这意味着 Kite 微服务在自身的环境中运行良好。如果需要将 Kite 微服务连接到另一个服务发现系统，则需要定制。这是我从列表中选择 Kite 并决定不介绍这个框架的重要原因之一

因此，如果您觉得这个博客很有用，并且想知道如何在 Golang 中创建多功能的微服务，那么请从我们这里雇佣 Golang开发者，并学习利用顶级的专业知识。

## 使用微服务应该遵循哪些原则？ ##

古人云：兵马未动，粮草先行。建设微服务是需要建立长远规划，不是像写CMS那样建好数据库表，然后就开始干活，这样十有八九是会失败的。我们要进行微服务改造前，架构师要提前做好规划，我们把这里分为三步，前期阶段，设计阶段，技术阶段

**前期阶段，大致要做好如下事情：**

- 和多方充分沟通，确保能符合客户和组织的需求，并且得到认同
- 和团队沟通，让队友（开发/测试/运维）理解，并且积极投入
- 和业务部门沟通，指定版本计划和上线时间
 

**设计阶段，**参考 Sam Newman 的著作《微服务设计》，单微服务必须要满足以下的条件，才符合微服务的基本要求：

- 标准的 REST 风格接口（基于 HTTP 和 JSON 格式）
- 独立部署，避免共享数据库（避免因为数据库而影响整个分布式系统）
- 业务上的高内聚，减少依赖（从设计上要避免服务过大或者太小）
 

**庞大的分布式系统，需要强大基础设施来支撑，微服务涉及哪些基础设施？**

- CI/CD和自动化（分布式系统几乎不可能通过人工手动发布）
- 虚拟化技术（要保证微服务运行环境隔离，目前行业主流的是使用 Docker 容器）
- 日志聚合，全链路监控（高度可观察和分析诊断问题）
 

说了那么多，那**什么样的情况下，你的团队不适合建设微服务**？（请勿对号入座）

- 开发团队不具备自主性，所在组织对开发团队限制非常多（具体请参考 康威定律）
- 团队不熟悉业务，无法识别出服务的边界，进行合理的拆分（请参考 DDD 领域驱动设计）

## 假如让你使用微服务架构时，你面临的挑战是什么？ ##

- 开发较小的微服务听起来很容易，但在开发时会经常遇到一些挑战。
- 自动化组件 难以自动化，因为有许多小的组件。对于每个组件，都必须采取构建、发布和监控的步骤；
- 可感知型 将大量组件维持在一起会带来难以部署、维护、监控和识别的问题。它需要在所有组件周围具有很好的感知能力。
- 配置管理 有时在各种环境中维护组件的配置会很困难；
- 调试 很难找到与产生错误相关的每一项服务。维护一个集中式的日志和控制面板对调试问题至关重要；

## 微服务常见问题的发现思路 ##

**微服务最大的问题：**


- 网络不可靠


为了实现高可用、高并发、高性能。我们需要面对如下的问题：

**客户端如何访问那么多的服务：**

- API网关


**服务与服务之间如何通信：**

- 同步通信：
	- HTTP（Apache Http Client）
	- RPC（Dubbo只支持Java，gRPC）
- 异步通信：
	- 消息队列（kafka，RabbitMQ，RocketMQ）

**那么多的服务如何管理：**

- 服务治理：
	- 服务注册和发现
	- 基于客户端的服务注册和发现
		- Apacche Zookeeper
	- 基于服务端的服务注册和发现
		- Netflix Eureka

**服务挂了怎么办：**

	- 重试机制
	- 服务熔断
	- 服务降级
	- 服务降流

**微服务的一些核心特性：**

	- 版本化、分布式配置
	- 服务注册和发现
	- 服务与服务之间的调用
	- 路由
	- 断路器和负载均衡
	- 分布式消息传递

