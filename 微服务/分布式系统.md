## 分布式系统是什么? ##
类比 **集中式系统**：集中式系统中整个项目就是一个独立的应用，整个应用也就是整个项目，所有的东西都在一个应用里面。集中式很明显的 **优点** 就是开发测试运维会比较方便，不用为考虑复杂的分布式环境。集中式很明显的 **弊端** 就是不易扩展，每次更新都必须更新所有的应用。而且，一个有问题意味着所有的应用都有问题。当系统越来越大，集中式将是系统最大的瓶颈。

**分布式系统：** ：分布式系统是若干独立计算机的集合，这计算机对用户来说就像单个相关系统。也就是说分布式系统背后是由一系列的计算机组成的，但用户感知不到背后的逻辑，就像访问单个计算机一样。

## 分布式系统 & 微服务架构 ##

微服务是**架构设计方式**，分布式是**系统部署方式**，两者概念不同；

- 微服务是指很小的服务，可以小到只完成一个功能，这个服务可以单独部署运行，不同服务之间通过rpc调用。
- 分布式是指服务部署在不同的机器上，一个服务提供一个或多个功能，服务之间也是通过rpc来交互或是webservice来交互。

两者的关系是，系统应用部署在超过一台服务器或者虚拟机上，且各分开部署的部分彼此通过各种通信协议交互信息，就可算作分布式部署，生产环境下微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同的服务器上，但是逻辑功能上还是单体应用。

- 分布式一个服务可以提供一个或者多个功能，微服务一个服务只能提供一个功能。
- 因性能问题，导致功能拆分，各自负责各自功能，这就是微服务架构。
- 分布式及微服务常见面试题，docker，kbernetes
- 设计微服务的一个重要关键就是低耦合、高内聚。
- 耦合：组件之间依赖关系的强度的度量（好的设计被认为：高内聚力、低耦合性）



## 分布式系统解决了什么问题，它又引入了新的什么问题？ ##
在分布式系统中：（分布式系统特点）

1. 应用可以按业务类型拆分成多个应用，再按结构分成接口层、服务层；我们也可以按访问入口分，如移动端、PC端等定义不同的接口应用；
1. 数据库可以按业务类型拆分成多个实例，还可以对单表进行分库分表；
1. 增加分布式缓存、搜索、文件、消息队列、非关系型数据库等中间件；

（**优点**）很明显，分布式系统可以解决集中式不便扩展的弊端，我们可以很方便的在任何一个环节扩展应用，就算一个应用出现问题也不会影响到别的应用。

随着微服务Spring Cloud & Docker的大热，及国内开源分布式Dubbo框架的重生，分布式技术发展非常迅速。

（缺点）分布式系统虽好，也**增加了系统的复杂性**，如分布式事务、分布式锁、分布式session、数据一致性等都是现在分布式系统中需要解决的难题，虽然已经有很多成熟的方案，但都不完美。分布式系统也**增加了开发测试运维成本**，工作量增加，分布式系统管理不好反而会变成一种负担。

## 分布式系统引出的问题及解决办法 ##

**分布式系统增加了系统复杂性**


## Etcd、分布式锁? ##

官方定义：A highly-available key value store for shared configuration and service discovery.

是一个键值存储仓库，用于**配置共享和服务发现**。

实际上，etcd 作为一个受到 ZooKeeper 与 doozer 启发而催生的项目，除了拥有与之类似的功能外，更专注于以下四点。

- 简单：基于 HTTP+JSON 的 API 让你用 curl 就可以轻松使用。
- 安全：可选 SSL 客户认证机制。
- 快速：每个实例每秒支持一千次写操作。
- 可信：使用 Raft 算法充分实现了分布式。

### Etcd如何实现分布式锁? ###
因为 Etcd 使用 Raft 算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。

（1）保持独占：
保持独占即所有获取锁的用户最终只有一个可以得到。etcd 为此提供了一套实现分布式锁原子操作 CAS（CompareAndSwap）的 API。通过设置prevExist值，可以保证在多个节点同时去创建某个目录时，只有一个成功。而创建成功的用户就可以认为是获得了锁。

（2）控制时序：
即所有想要获得锁的用户都会被安排执行，但是获得锁的顺序也是全局唯一的，同时决定了执行顺序。etcd 为此也提供了一套 API（自动创建有序键），对一个目录建值时指定为POST动作，这样 etcd 会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。同时还可以使用 API 按顺序列出所有当前目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。


**在这里Ectd实现分布式锁基本实现原理为：**

1. 在ectd系统里创建一个key
1. 如果创建失败，key存在，则监听该key的变化事件，直到该key被删除，回到1
1. 如果创建成功，则认为我获得了锁

## 分布式锁 ##
保证了数据的强一致性。锁服务可以分为两类，一个是保持独占，另一个是 控制时序。

1. 所谓保持独占，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把 zk 上的一个 znode 看作是一把锁，通过 create znode 的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。

2. 控制时序，就是所有视图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里 /distributelock 已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERALSEQUENTIAL 来指定）。Zk 的父节点（/distribute_lock）维持一份 sequence, 保证子节点创建的时序性，从而也形成了每个客户端的全局时序。
## 分布式锁的实现 ##
分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。

在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。

通常分布式锁以单独的服务方式实现，目前比较常用的分布式锁实现有三种：

1. 基于数据库实现分布式锁。
1. 基于缓存（redis，memcached，tair）实现分布式锁。
1. 基于Zookeeper实现分布式锁。

尽管有这三种方案，但是不同的业务也要根据自己的情况进行选型，他们之间没有最好只有更适合！
### （1）基于数据库的实现方式 ###
基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。

使用基于数据库的这种实现方式很简单，但是对于分布式锁应该具备的条件来说，它有一些问题需要解决及优化：

1. 因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换；
1. 不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁；
1. 没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据；
1. 不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。
1. 在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。

### （2）基于Redis的实现方式 ###
选用Redis实现分布式锁原因：

1. Redis有很高的性能；
1. Redis命令对此支持较好，实现起来比较方便

主要实现方式:

1. SET lock currentTime+expireTime EX 600 NX，使用set设置lock值，并设置过期时间为600秒，如果成功，则获取锁；
1. 获取锁后，如果该节点掉线，则到过期时间lock值自动失效；
1. 释放锁时，使用del删除lock键值；

使用redis单机来做分布式锁服务，可能会出现单点问题，导致服务可用性差，因此在服务稳定性要求高的场合，官方建议使用redis集群（例如5台，成功请求锁超过3台就认为获取锁），来实现redis分布式锁。详见RedLock。

- 优点：性能高，redis可持久化，也能保证数据不易丢失,redis集群方式提高稳定性。
- 缺点：使用redis主从切换时可能丢失部分数据。

### （3）基于ZooKeeper的实现方式 ###
ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：

1. 创建一个目录mylock；
1. 线程A想获取锁就在mylock目录下创建临时顺序节点；
1. 获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
1. 线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
1. 线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。
2. 
这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。

- 优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。
- 缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。

上面的三种实现方式，没有在所有场合都是完美的，所以，应根据不同的应用场景选择最适合的实现方式。
在分布式环境中，对资源进行上锁有时候是很重要的，比如抢购某一资源，这时候使用分布式锁就可以很好地控制资源。

## 你对分布式事务的理解？ ##
分布式事务是单个事件导致两个或多个不能以原子方式提交的单独数据源的突变的情况。在微服务的世界中，它变得更加复杂，因为每个服务都是一个工作单元，并且在大多数情况下，多个服务必须协同工作才能使业务成功。