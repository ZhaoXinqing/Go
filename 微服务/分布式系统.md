
分布式系统：
    - 是一种系统部署方式，是将一个系统拆分成多个子系统并分布到多个服务器上，但用户感知不到背后的逻辑，就像访问单个计算机一样。简单的说，是指将用户界面、控制台服务、数据库管理三个层次部署在不同的位置上。其中用户界面是客户端实现的功能，控制台服务是一个专门的服务器，数据管理是在一个专门的数据库服务器上实现的。
    - 优点：
        - 解决集中式不便扩展的弊端，既可以针对应用进行硬扩展（性能水平扩展），也可以对应用进行软扩展（增加分布式缓存、消息队列、非关系型数据库等中间件），还一定程度上提供了业务隔离，就算一个应用出现问题也不会影响到别的应用。
    - 缺点：
        - 增加了开发系统的复杂性：如分布式事务、分布式锁、分布式session、数据一致性等。
        - 增加了开发测试运维成本：工作量增加，分布式系统管理不好反而会变成一种负担。

分布式锁：
    - 锁服务可以分为两类，一个是保持独占，另一个是控制时序，分布式锁其实可以理解为：控制分布式系统有序的去对共享资源进行操作，通过互斥来保持一致性
    - 三种实现方案：	
        1、数据库实现（乐观锁）
            - 乐观锁实现
                - 一般是通过为数据库表添加一个 “version”字段来实现读取出数据时，将此版本号一同读出，之后更新时，对此版本号加1，在更新过程中，会对版本号进行比较，如果是一致的，没有发生改变，则会成功执行本次操作；如果版本号不一致，则会更新失败，实际就是个diff过程;
                - 缺点：
                    - 本一次的update操作，必须变为2次操作: select版本号一次；update一次，增加了数据库操作的次数
                    - 用基于数据库资源表的乐观锁，为保证数据一致性，一次业务流程中的多个资源都有一张资源表，在高并发的要求下，对数据库连接的开销一定是无法忍受；
                    - 乐观锁机制往往基于系统中的数据存储逻辑，因此可能会造成脏数据被更新到数据库中可能产生脏数据
        
2、基于Redis的实现（推荐）；
    - 使用Redis SETNX 命令实现分布式锁
    SETNX lock.foo <current Unix time + lock timeout + 1>
        - SETNX 返回1，说明该进程获得锁，SETNX将键 lock.foo 的值设置为锁的超时时间（当前时间 + 锁的有效时间）。
        - SETNX 返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁。
    

        3、基于zookeeper的实现：
            - ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。
            - 使用zookeeper创建临时序列节点来实现分布式锁，适用于顺序执行的程序，大体思路就是创建临时序列节点，找出最小的序列节点，获取分布式锁，程序执行完成之后此序列节点消失，通过watch来监控节点的变化，从剩下的节点的找到最小的序列节点，获取分布式锁，执行相应处理，依次类推……
            
