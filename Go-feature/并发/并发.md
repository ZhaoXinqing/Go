
Go并发：
    - Go通过使用goroutine和channel，提供了更容易的并发使用方法，其中goroutine来自协程的概念，即让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被 runtime 调度，转移到其他可运行的线程上。
    - Goroutine特点：占用内存更小（几kb）、调度更灵活（runtime调度)


    3、协程goroutine：
        - 是Golang实际并发执行的实体，它底层是使用协程(coroutine)实现并发，coroutine是一种运行在用户态的用户线程，类似于 greenthread，go底层选择使用coroutine的出发点是因为，它具有以下特点：
            1) 用户空间 避免了内核态和用户态的切换导致的成本。
            2) 可以由语言和框架层进行调度。
            3) 更小的栈空间允许创建大量的实例。
        - 协程Goroutine在Go语言中属于轻量级的线程，在运行时由runtim管理；

    4、通道channel：
        - channel 是被单独创建并且可以在进程之间传递，一个实体通过将消息发送到channel 中，然后有监听这个 channel 的实体处理，两个实体之间是匿名的，这个就实现实体中间的解耦，其中 channel 是同步的一个消息被发送到 channel 中，最终是一定要被另外的实体消费掉的，在实现原理上其实类似一个阻塞的消息队列。

        - 没有缓冲(buffer)的channel只能容纳一个元素，而带有缓冲(buffer)channel则可以非阻塞容纳N个元素。发送数据到缓冲(buffer) channel不会被阻塞，除非channel已满；同样的，从缓冲(buffer) channel取数据也不会被阻塞，除非channel空了。

        - Go语言中倡导使用channel作为gorountine之间同步和通信的手段。Channel类型属于引用类型，且每个channel只能传递固定类型的数据，channel作为一个队列，它会保证数据收发顺序总是遵循先入先出的原则进行，同时它也会保证同一时刻内仅有一个gorountine访问channel来发送和获取数据；

        - 带缓冲的channel，使用switch从多个channel中读取数据；

        - channel怎么做到线程安全？
            channel也可以理解为一个先进先出的队列，通过管道进行通信，主要目的就是在多任务间传递数据的，这当然是安全的；

        - golang 的 select 就是监听 IO 操作
            - case 里面应该是一个面向channel的IO操作，然后触发相应的动作。
            - https://www.jianshu.com/p/245d9cbfe132
    
    5、sync同步包
        - Goroutine和chan，一个用于并发，一个用于通信。没有缓冲的通信具有同步的功能，除此之外，sync包也提供了多个goroutine同步的机制，主要通过WaitGroup实现的。

        - 在Go语言中，除了使用channl进行gorountine之间的通信和同步操作外，还可以使用sync包下的并发工具；
            sync.Mutex互斥锁：
                - 控制多goroutine串行执行；
            sync.RWMutex读写锁：
                - 同一时间段只能一个Goroutine获得写锁，但多个goroutine可获得读锁；
            WaitGroup并发等待组：
                - 等待预设好数量的goroutine都提交执行结束后，才会继续往下执行代码；
            Sync.Map并发安全字典：
                - 添加了同步控制的字典，原生Map不是并发安全的，在多个goroutine同时往Map中添加数据时，可能会导致添加数据的丢失；
    
Golang 中的三种并发模型
    1、通过channel通知实现并发控制
        - 无缓冲的通道指的是通道的大小为0，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止。这种无缓冲的通道我们也称之为同步通道。当主 goroutine 运行到 <-ch 接受 channel 的值的时候，如果该 channel 中没有数据，就会一直阻塞等待，直到有值，这样就可以简单实现并发控制；

    2、通过sync包中的WaitGroup实现并发控制
        - Goroutine是异步执行的，有的时候为了防止在结束main函数的时候结束掉Goroutine，所以需要同步等待，这个时候就需要用 WaitGroup了，在sync包中，提供了WaitGroup，它会等待它收集的所有goroutine任务全部完成。
        - 在WaitGroup里主要有三个方法:
            - Add, 可以添加或减少 goroutine的数量.
            - Done, 相当于Add(-1).
            - Wait, 执行后会堵塞主线程，直到WaitGroup 里的值减至0.
        - 在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。 在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回返回。

    3、在Go 1.7 以后引进的强大的Context上下文，实现并发控制：
        - 通常,在一些简单场景下使用channel和WaitGroup已经足够了，但是当面临一些复杂多变的网络并发场景下 channel和WaitGroup显得有些力不从心了。比如一个网络请求Request，每个Request 都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的 goroutine，比如数据库和RPC服务。所以我们需要一种可以跟踪goroutine的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的 Context，称之为上下文非常贴切，它就是goroutine 的上下文。 它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go 将这些封装在一个 Context 里，再将它传给要执行的 goroutine 。
        - context 包主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。
        - context 包的核心是 struct Context，
            - Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个取消信号，
            - Err() 在Done() 之后，返回context 取消的原因。
            - Deadline() 设置该context cancel的时间点
            - Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。
        - Context对象是线程安全的，你可以把一个Context对象传递给任意个数的gorotuine，对它执行取消操作时，所有goroutine都会接收到取消信号。
        - 一个 Context 不能拥有 Cancel 方法，同时我们也只能 Done channel 接收数据。 其中的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。 典型的场景是：父操作为子操作操作启动 goroutine，子操作也就不能取消父操作。

协程的退出：
    - 1 通过Channel传递退出信号
        - Go的一大设计哲学就是：通过Channel共享数据，而不是通过共享内存共享数据。主流程可以通过channel向任何goroutine发送停止信号，但是当goroutine特别多的时候，这种方式不管在代码美观上还是管理上都显得笨拙不堪。
 
    2、使用wait group：
        - sync包中的Waitgroup结构，是Go语言为我们提供的多个goroutine之间同步的好刀
        - 通常情况下，我们像下面这样使用waitgroup:
            - 创建一个Waitgroup的实例，假设此处我们叫它wg
            - 在每个goroutine启动的时候，调用wg.Add(1)，这个操作可以在goroutine启动之前调用，也可以在goroutine里面调用。当然，也可以在创建n个goroutine前调用wg.Add(n)
            - 当每个goroutine完成任务后，调用wg.Done()
            - 在等待所有goroutine的地方调用wg.Wait()，它在所有执行了wg.Add(1)的goroutine都调用完wg.Done()前阻塞，当所有goroutine都调用完wg.Done()之后它会返回。
            - https://blog.csdn.net/m0_37579159/article/details/79257397
 
    3、使用select退出：
        - select常用于gorotine的完美退出
        - golang 的 select 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作
        - 每个case语句里必须是一个IO操作，确切的说，应该是一个面向channel的IO操作