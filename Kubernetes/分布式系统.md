分布式系统：
1、是将一个系统拆分成多个子系统并分布到多个服务器上的一种系统部署方式，通常是为了实现系统扩展的目的。既可以针对应用进行硬扩展（性能水平扩展），也可以对应用进行软扩展（增加分布式缓存、消息队列、非关系型数据库等中间件），还一定程度上提供了业务隔离，就算一个应用出现问题也不会影响到别的应用。
2、缺点：
    (1)增加了开发系统的复杂性：如分布式事务、分布式锁、分布式session、数据一致性等。
    (2)增加了开发测试运维成本：工作量增加，分布式系统管理不好反而会变成一种负担。
3、分布式事务：
    (1)如何确保：
        ①强一致性（一个副本变更，保证所有副本更新）；
        ②分布式数据一致性工业级解决方案：Zookeeper;
    (2)解决分布式事务的两个理论：
        1、CAP理论:
            1)分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partitiontolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。
            2)由于网络硬件肯定会出现延迟丢包等问题，所以通常情况下，牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。
        2、BASE理论:	
            1)是BasicallyAvailable（基本可用）、Softstate（软状态）和Eventuallyconsistent（最终一致性）三个短语的简写。
            2)-是对CAP中一致性和可用性权衡的结果，它减少的对数据一致性支持，从而获得了基本一致性和柔和可靠性，其核心思想是即使无法做到强一致性（Strongconsistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventualconsistency）;
4、分布式锁：
    (1)锁服务可以分为两类，一个是保持独占，另一个是控制时序，分布式锁其实可以理解为：控制分布式系统有序的去对共享资源进行操作，通过互斥来保持一致性；
    (2)三种实现方案：
    1、数据库实现（乐观锁）
        1)通过为数据库表添加一个“version”字段来实现读取出数据时，将此版本号一同读出，之后更新时，对此版本号加1，在更新过程中，会对版本号进行比较，如果是一致的，没有发生改变，则会成功执行本次操作；如果版本号不一致，则会更新失败，实际就是个diff过程;
        2)缺点：本一次的update操作，必须变为2次操作:select版本号一次；update一次，增加了数据库操作的次数
        3)-用基于数据库资源表的乐观锁，为保证数据一致性，一次业务流程中的多个资源都有一张资源表，在高并发的要求下，对数据库连接的开销一定是无法忍受；
        4)乐观锁机制往往基于系统中的数据存储逻辑，因此可能会造成脏数据被更新到数据库中可能产生脏数据
    2、基于Redis的实现（推荐）；
        1)使用RedisSETNX命令实现分布式锁：SETNXlock.foo<currentUnixtime+locktimeout+1>
            a.-SETNX返回1，说明该进程获得锁，SETNX将键lock.foo的值设置为锁的超时时间（当前时间+锁的有效时间）。
            b.-SETNX返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试SETNX操作，以获得锁。
    3、基于zookeeper的实现：
        1)ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。
        2)使用zookeeper创建临时序列节点来实现分布式锁，适用于顺序执行的程序，大体思路就是创建临时序列节点，找出最小的序列节点，获取分布式锁，程序执行完成之后此序列节点消失，通过watch来监控节点的变化，从剩下的节点的找到最小的序列节点，获取分布式锁，执行相应处理，依次类推……
5、Redis解决死锁：
    (1)程序挂掉，没有释放锁，其它此程序一直出现等待的状态
    (2)-将键lock.foo的值设置为锁的有效时间，进程获得锁后，其他进程还会不断的检测锁是否已超时，如果超时，那么等待的进程也将有机会获得锁。
    (3)检测到锁超时后，进程不能直接简单地执行DEL删除键的操作以获得锁（防止多种进程获得锁）
    (4)检测到锁已超时，即当前的时间大于键lock.foo的值，P2执行以下操作
        ①GETSETlock.foo<currentUnixtimestamp+locktimeout+1>
        ②GETSET操作在设置键的值的同时，还会返回键的旧值，通过比较键lock.foo的旧值是否小于当前时间，可以判断进程是否已获得锁。
        ③假如另一个进程P3也检测到锁已超时，并在P2之前执行了GETSET操作，那么P4的GETSET操作返回的是一个大于当前时间的时间戳，这样P3就不会获得锁而继续等待。
        ④执行DELlock.foo操作前，需要先判断锁是否已超时。如果锁已超时，那么锁可能已由其他进程获得，这时直接执行DELlock.foo操作会导致把其他进程已获得的锁释放掉。
        ⑤-https://www.jb51.net/article/104111.htm
     
            
