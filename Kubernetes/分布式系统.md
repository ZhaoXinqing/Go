## 分布式系统：
是一种系统拆分的部署方式，通常是为了实现系统扩展的目的。既可以针对应用进行硬扩展（性能水平扩展），也可以对应用进行软扩展（增加分布式缓存、消息队列、非关系型数据库等中间件），还一定程度上提供了业务隔离，防止服务间的相互影响。
【缺点】增加了开发系统的复杂性：如分布式事务、分布式锁、分布式session、数据一致性等；增加了开发测试运维成本，分布式系统管理不好反而会变成一种负担。

## 分布式事务：
强一致性（一个副本变更，保证所有副本更新），分布式数据一致性工业级解决方案：Zookeeper。分布式事务的两个理论：
【CAP理论】任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partitiontolerance），最多只能同时满足两项。”所以，系统在设计之初就要对这三者做出取舍。由于网络硬件肯定会出现延迟丢包等问题，所以通常情况下，牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。
【BASE理论】是BasicallyAvailable（基本可用）、Softstate（软状态）和Eventuallyconsistent（最终一致性）三个短语的简写。其核心思想是即使无法做到强一致性（Strongconsistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventualconsistency）;

## 分布式锁：
锁服务可以分为两类，一个是保持独占，另一个是控制时序，分布式锁其实可以理解为：控制分布式系统有序的去对共享资源进行操作，通过互斥来保持一致性；
【基于数据库】（乐观锁）
    通过为数据库表添加一个“version”字段来实现读取出数据时，将此版本号一同读出，之后更新时，对此版本号加1，在更新过程中，会对版本号进行比较，如果是一致的，没有发生改变，则会成功执行本次操作；如果版本号不一致，则会更新失败，实际就是个diff过程;
    【缺点】本一次的update操作，必须变为2次操作:select版本号一次；update一次，增加了数据库操作的次数，在高并发的要求下，对数据库连接的开销一定是无法忍受；乐观锁机制往往基于系统中的数据存储逻辑，因此可能会造成脏数据被更新到数据库中。
【基于Redis】（推荐）；
    使用RedisSETNX命令实现分布式锁：SETNXlock.foo<currentUnixtime+locktimeout+1>
        a.-SETNX返回1，说明该进程获得锁，SETNX将键lock.foo的值设置为锁的超时时间（当前时间+锁的有效时间）。
        b.-SETNX返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试SETNX操作，以获得锁。
【基于zookeeper】
    ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。通过zookeeper创建临时序列节点，找出最小的序列节点，获取分布式锁，程序执行完成之后此序列节点消失，通过watch来监控节点的变化，从剩下的节点的找到最小的序列节点，获取分布式锁，执行相应处理，依次类推……

## Redis解决死锁：
设置锁的有效时间，通过超时设置，释放删除锁；其次，在执行DELlock.foo操作前，需要先判断锁是否已超时。如果锁已超时，那么锁可能已由其他进程获得，这时直接执行DELlock.foo操作会导致把其他进程已获得的锁释放掉。可以通过返回时间戳的方式避免删除已经新建立锁的进程

     
            
