Go是一种新的语言，一种并发的、带垃圾回收的、快速编译的语言。它具有以下特点：
- [内置并发编程支持](https://www.jianshu.com/p/63dbec263d2a)
- 使用协程（goroutine）做为基本的计算单元。轻松地创建协程。
- 使用数据通道（channels）来实现协程间的同步和通信。
- 内置了映射（map）和切片（slice）类型。
- [支持多态（polymorphism）](https://blog.csdn.net/jw915086731/article/details/86751334)。
- 使用接口（interface）来实现装盒（value boxing）和反射（reflection）。
- [支持指针。](http://c.biancheng.net/view/21.html)
- 支持函数闭包（closure）。https://www.cnblogs.com/hzhuxin/p/9199332.html
- 支持方法。
- 支持延迟函数调用（defer）。
- 支持类型内嵌（type embedding）。
- 支持类型推断（type deduction or type inference）。
- [内存安全。](https://blog.csdn.net/wenrennaoda/article/details/95935355)
- 自动垃圾回收。
- 良好的代码跨平台性。

## 匿名函数和闭包
Go 支持通过 闭包来使用 匿名函数。匿名函数在你想定义一个不需要命名的内联函数时是很实用的。由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包
https://blog.csdn.net/ycy258325/article/details/54632915

## 并发
独特的MPG的线程模型和CSP并发理念也为Go语言高性能、高并发的特性增分不少；
https://www.cnblogs.com/qingaoaoo/p/13295835.html

## Gomodule
Go module的出现有效解决了Go语言依赖混乱的问题；

## 反射
提供给开发商在运行时对代码进行修改的能力，方便各种框架（如注入依赖框架）的实现；



## golang-map
https://studygolang.com/articles/23184?fr=sidebar




## go的值传递和引用
值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。
引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。
**默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数**

## 方法
Go 自动处理方法调用时的值和指针之间的转化。你可以使用指针来调用方法来避免在方法调用时产生一个拷贝，或者让方法能够改变接受的数据。

## 接口
接口 是 方法特征 的命名集合

## 错误处理
Go 语言使用一个独立的·明确的返回值来传递错误信息的。这与使用异常的 Java 和 Ruby 以及在 C 语言中经常见到的超重的单返回值/错误值相比，Go 语言的处理方式能清楚的知道哪个函数返回了错误，并能像调用那些没有出错的函数一样调用。

按照惯例，错误通常是最后一个返回值并且是 error 类型，一个内建的接口。

## 强类型的静态编译型语言
https://blog.csdn.net/ling12abc/article/details/102993484



## 1. 关于函数 ##
函数是基于功能或 逻辑进行封装的可复用的代码结构。将一段功能复杂、很长的一段代码封装成多个代码片段（即函数），有助于提高代码可读性和可维护性。

在 Go 语言中，函数可以分为两种：

- 带有名字的普通函数
- 没有名字的匿名函数

由于 Go语言是编译型语言，所以函数编写的顺序是无关紧要的，它不像 Python 那样，函数在位置上需要定义在调用之前。


## 2. 函数的声明 ##
函数的声明，使用 func 关键字，后面依次接 函数名，参数列表，返回值列表，用 {} 包裹的代码逻辑体

	func 函数名(形式参数列表)(返回值列表){
	    函数体
	}

- 形式参数列表描述了函数的参数名以及参数类型，这些参数作为局部变量，其值由参数调用者提供
- 返回值列表描述了函数返回值的变量名以及类型，如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。

举个例子，定义一个 sum 函数，接收两个 int 类型的参数，在运行中，将其值分别赋值给 a，b，并规定必须返回一个int类型的值 。

	func sum(a int, b int) (int){
	    return a + b}func main() {
	fmt.Println(sum(1,2))}



## 4. 多个可变参数函数传递参数 ##




## 一、变量类型 ##
变量分为值类型，指针类型和引用类型。

- 在golang中故意淡化了指针的概念，我们只需要关注值类型和引用类型就可以。你在官方介绍中也很少看到指针类型这一概念

## 二、值类型和引用类型的区别 ##
- 值类型变量：除开slice,map, channel类型之外的变量都是值类型
- 引用类型变量：slice, map, channel这三种。
### 1，零值不同 ###
- 指针类型的变量，零值都是nil。
- 值类型的变量，零值是其所在类型的零值。
	1. int32类型的零值是0
	1. string类型的零值是""
	1. bool类型的零值是false
	1. 符合结构struct类型的零值是其每个成员的零值的组合

### 2，变量申明后是否需要初始化才能使用


	
## 三、make和new的区别
- make返回的是对象。
	- 对值类型对象的更改，不会影响原始对象的值
	- 对引用类型对象的更改，会影响原始对象的值
- new返回的是对象的指针，对指针所在对象的更改，会影响指针指向的原始对象的值。

## 四、golang没有引用传递，都是值传递

- 如果函数形参是值类型，则会对值类型做一份拷贝作为函数形参。在函数内对形参变量做的修改，不会影响函数外的那个被传入的变量。
- 如果函数形参是引用类型，则会对引用类型变量做一次拷贝。但是拷贝得到的引用类型变量的值，和被传入调用函数的原始引用类型变量的值，是一样的，即指向的是同一个变量的地址(参考前面值类型变量和引用类型变量图)。所以在函数里面的修改，会影响原始引用变量指向的变量的值。


## 什么是内存泄露 ##
内存泄露指的是程序运行过程中已不再使用的内存，没有被释放掉，导致这些内存无法被使用，直到程序结束这些内存才被释放的问题。

Go虽然有GC来回收不再使用的堆内存，减轻了开发人员对内存的管理负担，但这并不意味着Go程序不再有内存泄露问题。在Go程序中，如果没有Go语言的编程思维，也不遵守良好的编程实践，就可能埋下隐患，造成内存泄露问题。

## 怎么发现内存泄露 ##
在Go中发现内存泄露有2种方法，一个是通用的监控工具，另一个是go pprof：


1. 监控工具：固定周期对进程的内存占用情况进行采样，数据可视化后，根据内存占用走势（持续上升），很容易发现是否发生内存泄露。
2. go pprof：适合没有监控工具的情况，使用Go提供的pprof工具判断是否发生内存泄露。

## 方法引用 ##
1：同一个包下公有方法（方法名首字母大写）和可直接引用 <br>2：不通包下的公有方法要加上包名以进行引用

## Goalng方法是依托于结构体的 ##

结构体和其他面向对象语言中的class同等地位。
Golang中方法就是一个包含了接收者的函数，接收者可以是一个命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。


    





　　
## 手写洗牌

## 使用go过程使用踩过什么坑
https://studygolang.com/articles/16949?fr=sidebar


**<p align = right> --靠自己**</p>