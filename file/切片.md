# Golang切片与函数参数“陷阱”

线性结构是计算机最常用的数据结构之一,golang有数组，还提供了切片（slice）。
切片比数组有更好的灵活性，具有某些动态特性。

## slice

slice结构大致存储了三个部分，第一部分为指向底层数组的指针`ptr`，其次是切片的大小`len`和切片的容量`cap`：

假设有一个数组`arr`是一个包含五个int类型的结构，它的切片slice只是从其取了 1到3这几个数字。我们同样可以再生成一个切片 `slice2 := arr[2:5]`, 所取的就是数组后面的连续块。他们共同使用arr作为底层的结构，它们共用了数字的第3，4个元素，修改其中任何一个，都能改变两个切片的值。

数组的切片，只是从数组上切一段数据下来，不同的切片，其实是共享这些底层的数据数据。不过这些切片本身是不一样的对象，其内存地址都不一样。

从数组中切一块下来形成切片很好理解，有时候我们用make函数创建切片，实际上golang会在底层创建一个匿名的数组。如果从新的slice再切，那么新创建的两个切片都共享这个底层的匿名数组。

## slice的复制

golang实现了一个内建的函数`copy`， copy有两个参数，第一个参数是复制后的对象，第二个是复制前的数组切片对象。

## slice 追加

`append`函数用于给切片追加元素。append第一个参数为原切片，随后是一些可变参数，用于将要追加的元素或多个元素。
使用append时候，本质上是针对底层依赖的数组进行操作。如果切片的容量大于长度，给切片追加元素其实是修改底层数中切片元素后面的元素。如果容量满了，就不能在原来的数组上修改，而是要创建一个新的数组，当然golang是通过创建一个新的切片实现的，因为新切片必然也有一个新的数组，并且这个数组的长度是原来的2倍，使用动态规划算法的简单实现。

## 切片容量

数组和切片都有长度限制。追加切片的时候，如果元素正好在切片的容量范围内，直接在尾部追加一个元素即可。如果超出了最大容量，再追加元素就需要针对底层的数组进行复制和扩容操作了。

这里有一个切片容量的概念，从数组中切数据，切片的容量应该是切片的最后一个数据，和数组剩下元素的大小，再加上现有切片的大小。


## 作为函数参数的切片

切片传递的时候，传的是数组的值，等效于从原始切片中再切了一次。原始切片slice和参数s切片的底层数组是一样的。因此修改函数内的切片，也就修改了数组。

当slice传递给函数的时候，新建了切片s。在函数中给s进行了append一个元素，由于此时s的容量足够到，并没有生成新的底层数组。当修改返回的ret的时候，ret也共用了底层的数组，因此修改ret的原始，相应的也看到了slice的改变。

如果在函数内，append操作超过了原始切片的容量，将会有一个新建底层数组的过程，那么此时再修改函数返回切片，将不会再影响原始切片。

总结：slice或者array作为函数参数传递的时候，外面的原始切片是否改变，取决于函数内的操作和切片本身容量。


## 总结

golang提供了array和slice两种序列结构。其中array是值类型。slice则是复合类型。slice是基于array实现的。slice的第一个内容为指向数组的指针，然后是其长度和容量。通过array的切片可以切出slice，也可以使用make创建slice，此时golang会生成一个匿名的数组。
因为slice依赖其底层的array，修改slice本质是修改array，而array又是有大小限制，当超过slice的容量，即数组越界的时候，需要通过动态规划的方式创建一个新的数组块。把原有的数据复制到新数组，这个新的array则为slice新的底层依赖。
数组还是切片，在函数中传递的不是引用，是另外一种值类型，即通过原始变量进行切片传入。函数内的操作即对切片的修改操作了。当然，如果为了修改原始变量，可以指定参数的类型为指针类型。传递的就是slice的内存地址。函数内的操作都是根据内存地址找到变量本身。