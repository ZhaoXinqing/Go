## Mysql存储引擎:

​        Innodb引擎，Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。
​        MyIASM引擎(原本Mysql的默认引擎),不提供事务的支持，也不支持行级锁和外键。
同一个数据库也可以使用多种存储引擎的表。如果一个表修改要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。

MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？

答案:都是B+树!
MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。

Innodb引擎的索引的数据结构也是B+树，只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。

## 优化思路：

​        SQL优化：选择最有效率的表名顺序，WHERE子句中的连接顺序，SELECT子句中避免使用*号，用TRUNCATE替代DELETE，多使用内部函数提高SQL效率（例如使用mysql的concat()函数会比使用||来进行拼接快，因为concat()函数已经被mysql优化过了），使用表或列的别名（如果表或列的名称太长了，使用一些简短的别名也能稍微提高一些SQL的性能。毕竟要扫描的字符长度就变少了），多使用commit（comiit会释放回滚点…），善用索引，SQL写大写（因为Oracle服务器总是先将小写字母转成大写后，才执行），

        数据库结构优化：范式优化： 比如消除冗余（节省空间），反范式优化：比如适当加冗余等（减少join），拆分表： 垂直拆分和水平拆分；
    
        服务器硬件优化（多花钱咯）；

MySQL数据库：

## 1、索引：

(1)不用遍历，基本上直接定位数据，加快数据查询速度；但在插入和修改数据时，因为要对索引也进行更新，所以要花费较多额外时间，且索引会增加了数据库的存储空间；
(2)innoDB默认索引类型为B+树，非叶节点仅具有索引作用，叶子结点的指针指向的是被索引的完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这种索引叫做“聚焦索引”且叶子节点之间形成链表，从而方便了叶子结点的遍历与范围查找；
①在InnoDB有一个特殊的功能叫做自适应哈希索引，当它发现某些索引值被使用的非常频繁时，它会在内存中基于B+树索引之上再创建一个hash索引，加快数据的查找速度。
②聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索（非聚焦索引）需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录；所以效率低一点；
(3)哈希虽然能够提供O（1）的单数据行性能，但是对于范围查询和排序却无法很好地支持，最终导致全表扫描；B树能够在非叶节点中存储数据，但是这也导致在查询连续数据时可能会带来更多的随机I/O，B+树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机I/O；
(4)聚簇索引&非聚簇索引：
①InnoDB的主键使用的都是聚簇索引，而MyASM无论是主键索引还是二级索引，使用的都是非聚簇索引。
②聚簇索引的查找记录要比非聚簇索引块，因为聚簇索引是将索引和整条记录存放在一起，找到索引就找到了记录，而非聚簇索引只存储索引字段和记录所在的位置，通过索引找到记录所在的位置，然后再根据记录所在位置去获取记录；
③一个数据表只能有一个聚簇索引，但可以有多个非聚簇索引；
(5)索引的最左前缀原则：在使用复合索引（在多个列上建立索引，在多条件查询时，效率较高）作为条件查询时，必须使用到该索引中的第一个字段作为条件才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。

## 2、事务和隔离：

(1)事务是恢复和并发控制的基本单位，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行；在关系型数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序。
①事务具有4个属性，通常称为ACID特性：原子性（atomicity），一致性（consistency），隔离性（isolation），持久性（durability）；
(2)MySQL中事务使用命令：starttransaction开启事务、Rollback回滚事务、Commit提交事务。
(3)InnoDB支持的四种事务隔离级别：
①ReadUncommitted（读取未提交）：所有的事务都可以看到其它未提交事务的执行结果，容易脏读，性能也不是太高，所以实践中很少使用；
②ReadCommitted（读取已提交）：只能看见已提交事务，是大多数数据库系统的默认隔离级别（但不是Mysql默认的）。支持不可重复度，因为同一事务的其它实例在该实例处理期间可能会有新的commit，所以同一select可能返回不同的结果；
③RepeatableRead（可重读）：MySQL的默认事务隔离级别，它确保同一事务在多个实例在并发读取数据时，会看到同样的数据行；不过理论上会导致幻读，指当用户读取某一范围的数据行时，会发现有新的“幻影”行，lnnoDB存储引擎通过多版本并发控制（MVCC，间隙锁）机制解决了该问题。（多版本解决不可重复读问题，间隙锁（并发控制）解决幻读问题）
④Serializable（串行化）：最高的隔离级别，它是在每个读的数据行上加上共享锁，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。但在这个级别下，可能导致大量的超时现象和锁竞争；

## (4)锁类型：

①全局锁：让整个库处于只读状态，常用于全库逻辑备份，Flushtableswithreadlock(FTWRL)；
②表锁：-locktables…read/write，释放：unlocktables			
③元数据锁MDL(metadatalock)：访问一个表的时候自动加上，保证读写正确性；增删改操作，加入MDL读锁；表结构更改，加入写锁；
④行锁：Innodb替代myisam的重要原因，是针对数据表中行记录的锁，锁粒度更小，提高执行效率；行锁是通过给索引上的索引项加锁来实现的，这一点与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。所以只有通过索引条件检索数据，InnoDB才使用行级锁，否则InnoDB将使用表锁。
⑤死锁：多线程之间在并发系统中出现资源循环依赖，线程都在等待别的线程释放资源，从而进入无限等待的状态。-应对策略：
1)设置超时时间参数（默认50秒），直到超时innodb_lock_wait_timeout;
2)发起死锁检测，回滚事务，将innodb_deadlock_detect设置为on开启；
3)建议第二种；在数据库服务端控制并发，降低死锁，考虑用中间件实现，在mysql中实现就是在进入引擎前排队，这样innodb内部就不会有大量的死锁检测工作了；
⑥间隙锁（GapLock）：为解决（在InnoDB在可重复提交下）幻读问题而引入的锁机制。当使用范围条件检索数据，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但不存在的记录，叫做“间隙（GAP）”，InnoDB也会对这些间隙加锁，这种锁机制就是所谓的间隙锁。但范围内不存在的键值也会被无辜锁定，无法插入锁定范围内的任何数据，导致执行效率下降；
⑦乐观锁和悲观锁：-区别在于拿数据的时候是否认为别人会不会修改，-乐观锁认为别人不会修改，所以拿数据时候不上锁，比较适合读操作比较频繁，并发冲突少的场景。-悲观锁则认为别人会修改，所以直接上锁，比较适合写操作比较频繁，强一致性的场景，效率比较低；
⑧自旋锁：让不满足条件的线程不立即挂起，而是循环等待，通过占用处理器（CPU）的时间来避免线程切换带来的开销；

## 3、SQL查询：

(1)CRUD：增加(Create)、查询(Retrieve）、更新(Update)和删除(Delete)
(2)删除：droptable直接删掉表；truncatetable删除表中数据，留下表结构，在插入时自增长id又从1开始；delete删除表中数据，可以加where子句；
(3)查询：select,目标from、过滤where、分组groupby、排序orderby、限定limit、去重distinct；
(4)优化：
①尽量避免全表扫描：where子句中对字段进行null值判断；使用!=或>操作符；用or来连接条件；in和notin的使用；模糊查询前置%，都会导致全表扫描；
②用具体的字段列表代替“*”，不要返回用不到的任何字段；
③在where及orderby常涉及的列上建立索引；
④使用varchar代替char，可以节省存储空间，在一个相对较小的字段内搜索效率显然要高些；
⑤索引不要过多，索引固然可以提高相应的select的效率，但同时也降低了insert及update的效率(insert或update时有可能会重建索引)，一个表的索引数最好不要超过6个；
⑥尽量使用数字型字段，字符型会降低查询和连接的性能（引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次）；
⑦索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。
(5)表创建三范式：
①属性不可再分：表中的字段都是单一属性，具有原子性，不可再分。
②消除冗余：-在第一范式的基础上，要求表中实例必须可以被唯一的区分，通常需要为表加上一列可以存储各个实例的唯一标识，即主键。
③消除传递依赖：满足第二范式的基础上，要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。
(6)表约束：为保证插入表的数据的完整性和正确性，在创建表时，对表的一些属性进行限定；
①主键(primarykey)：是一列或多列的组合，唯一地标识表中的每一行，用与记录的修改与删除，还可与另一张表的外键关联(foreignkey)，保证数据完整性。【非空(nonull)、唯一(unique)】；
②主键自增长(keyautoincrement) 
(7)SQL注入：一种常见的网络攻击方式，它通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器，执行恶意的SQL命令实现无账号登录，甚至篡改数据库的目的。解决办法：对用户输入的数据进行过滤处理，对不同的字段进行条件限制，符合条件的可以写入数据库，不符合条件的进行数据过滤掉！

## 4、数据库优化：

(1)MySQL问题排查：
①使用showprocesslist命令查看当前所有连接信息。
②使用explain命令查询SQL语句执行计划。
③开启慢查询日志，查看慢查询的SQL。
(2)可能导致数据查询慢的原因分析：
①缓存失效，在此一段时间内由于高并发访问导致MySQL服务器崩溃；
②SQL语句编写问题；
③MySQL服务器参数问题；
④硬件配置限制MySQL服务器性能问题；
(3)优化的入手方法：
①服务层面：配置mysql性能优化参数，数据库服务器提升硬件配置，或者数据库搭建集群；
②系统层面：
1)优化数据表结构、字段类型、字段索引：（索引不是越多越好，并不是所有索引对查询都有效，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用）		
2)分表、分库：
a.分库：当数据库中的表太多，可以考虑将表分到不同的数据库
b.分表：水平分表：将一些列分到另一张表；垂直分表：将历史信息分到另一张表中，很久之前的记录少有查询
3)读写分离：
a.通过数据库配置设置，mysql复制时，产生了多个数据副本（备库），为减少服务器压力，备库用于处理读操作，主库可同时处理读写。备库的复制是异步的，无法实时同步，读写分离的主要难点也在于备库上的脏数据。通常如果使用备库进行读，一般对数据的实时性要求不能太高。
③数据库层面：优化SQL语句，合理使用字段索引
④代码层面：使用缓存和NoSQL数据库方法存储，如MongoDB/Memcache/Redis来缓存高并发下数据库查询的压力
⑤减少数据库操作次数：尽量使用数据库访问驱动的批处理方法
⑥不常使用的数据迁移备份：避免每次都在海量数据中去检索
⑦编程手段防止SQL注入：使用JDBCPrepareStatement按位插入和查询；正则表达式过滤（非法字符串过滤）；

## 5、视图：

(1)包含某个查询的虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。
(2)通过视图用户只能查询和修改他们所能见到和有用的数据，降低数据的复杂程度；且用户可以被限制在数据的不同子集上，防止未经许可访问敏感数据，提高安全性能；
(3)临时表：借助临时表来提升查询临时效率，临时表加载于数据库内存上，使用之后就销毁；有会话临时表和全局临时表；

## 6、数据库连接池:

(1)（多用户的网页应用程序中）对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正是针对这个问题提出来的。
(2)数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中（数量是由最小数据库连接数制约），无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。

## 7、MVCC(多版本并发控制)：

(1)并发访问（读或写）数据库时，对正在事务内处理的数据做多版本的管理，以用来避免因写操作的堵塞引发读操作的并发问题。
(2)通过保存数据在某个时间点的快照来实现的；
(3)比锁定模型的优点是，在MVCC里对检索（读）数据的锁要求与写数据的锁要求不冲突，所以读不会阻塞写，而写也从不阻塞读。
(4)在数据库里也有表和行级别的锁定机制，用于给那些无法轻松接受MVCC行为的应用。不过，恰当地使用MVCC会提供比锁更好地性能。

## 8、char和varchar的区别是什么？

(1)char(n)：固定长度类型，效率高，但占用空间；适用场景：存储密码的md5值，固定长度的，使用char非常合适。
(2)varchar(n)：长度可变，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。
(3)从空间上考虑varcahr比较合适；从效率上考虑char比较合适，二者根据使用需要权衡。

## 9、float和double的区别是什么？

(1)float最多可以存储8位的十进制数，并在内存中占4字节。
(2)double最可可以存储16位的十进制数，并在内存中占8字节。

## 10、数据的更新方式：

(1)通知机制；
(2)用程序定时拉数据（看拉数据的间隔和执行效率）；

